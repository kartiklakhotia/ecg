$constant  ACCESS_ASR : $uint<3>:= 5  
$constant  ACCESS_PSR : $uint<3>:= 1  
$constant  ACCESS_REG : $uint<3>:= 6  
$constant  ACCESS_TBR : $uint<3>:= 2  
$constant  ACCESS_WIM : $uint<3>:= 3  
$constant  ACCESS_Y : $uint<3>:= 4  
$pipe  AJIT_to_ENV_addr : $uint<64>  $depth 2  $p2p 
// can point into 
$pipe  AJIT_to_ENV_byte_mask : $uint<8>  $depth 2  $p2p 
// can point into 
$pipe  AJIT_to_ENV_data : $uint<64>  $depth 2  $p2p 
// can point into 
$pipe  AJIT_to_ENV_processor_mode : $uint<8>  $depth 1 
// can point into 
$pipe  AJIT_to_ENV_request_type : $uint<8>  $depth 2  $p2p 
// can point into 
$constant  ALL_ONE_11 : $uint<11>:= _h7ff  
$constant  ALL_ONE_13 : $int<13>:= _h7ff  
$constant  ALL_ONE_8 : $uint<8>:= _b11111111  
$constant  ALU_INSTR : $uint<3>:= 2  
$constant  ANNUL_TRAP_BIT_VEC : $uint<32>:= 8  
$constant  ANNUL_TRAP_INDEX : $uint<32>:= 3  
$constant  ASI_AJIT_BRIDGE_CONFIG : $uint<8>:= _h30  
$constant  ASI_BLOCK_COPY : $uint<8>:= _h17  
$constant  ASI_BLOCK_FILL : $uint<8>:= _h1F  
$constant  ASI_CACHE_DATA_I : $uint<8>:= _h0D  
$constant  ASI_CACHE_DATA_I_D : $uint<8>:= _h0F  
$constant  ASI_CACHE_TAG_I : $uint<8>:= _h0C  
$constant  ASI_CACHE_TAG_I_D : $uint<8>:= _h0E  
$constant  ASI_FLUSH_I_CONTEXT : $uint<8>:= _h1B  
$constant  ASI_FLUSH_I_D_CONTEXT : $uint<8>:= _h13  
$constant  ASI_FLUSH_I_D_PAGE : $uint<8>:= _h10  
$constant  ASI_FLUSH_I_D_REGION : $uint<8>:= _h12  
$constant  ASI_FLUSH_I_D_SEGMENT : $uint<8>:= _h11  
$constant  ASI_FLUSH_I_D_USER : $uint<8>:= _h14  
$constant  ASI_FLUSH_I_PAGE : $uint<8>:= _h18  
$constant  ASI_FLUSH_I_REGION : $uint<8>:= _h1A  
$constant  ASI_FLUSH_I_SEGMENT : $uint<8>:= _h19  
$constant  ASI_FLUSH_I_USER : $uint<8>:= _h1C  
$constant  ASI_MMU_DIAGNOSTIC_I : $uint<8>:= _h05  
$constant  ASI_MMU_DIAGNOSTIC_IO : $uint<8>:= _h07  
$constant  ASI_MMU_DIAGNOSTIC_I_D : $uint<8>:= _h06  
$constant  ASI_MMU_FLUSH_PROBE : $uint<8>:= _h03  
$constant  ASI_MMU_REGISTER : $uint<8>:= _h04  
$constant  ASI_SUPERVISOR_DATA : $uint<8>:= _h0B  
$constant  ASI_SUPERVISOR_INSTRUCTION : $uint<8>:= _h09  
$constant  ASI_USER_DATA : $uint<8>:= _h0A  
$constant  ASI_USER_INSTRUCTION : $uint<8>:= _h08  
$constant  BLOCK_READ : $uint<1>:= 1  
$constant  CACHE_ARRAY_NOP : $uint<3>:= 3  
$constant  CACHE_ARRAY_PASS_THROUGH : $uint<3>:= 4  
$constant  CACHE_ARRAY_READ_DWORD : $uint<3>:= 1  
$constant  CACHE_ARRAY_WRITE_DWORD : $uint<3>:= 2  
$constant  CACHE_TAG_CLEAR_ALL : $uint<3>:= 4  
$constant  CACHE_TAG_CLEAR_LINE : $uint<3>:= 3  
$constant  CACHE_TAG_INSERT : $uint<3>:= 2  
$constant  CACHE_TAG_LOOKUP : $uint<3>:= 1  
$constant  CACHE_TAG_NOP : $uint<3>:= 5  
$constant  CCU_DBG_BP_HIT : $uint<8>:= 2  
$constant  CCU_DBG_CONNECT_RQST : $uint<8>:= 1  
$constant  CCU_DBG_ERROR : $uint<8>:= 7  
$constant  CCU_DBG_ERROR_MODE : $uint<8>:= 6  
$constant  CCU_DBG_OK : $uint<8>:= 8  
$constant  CCU_DBG_READ_RESPONSE : $uint<8>:= 9  
$constant  CCU_DBG_READ_WP_HIT : $uint<8>:= 3  
$constant  CCU_DBG_THREAD_FINISH : $uint<8>:= 5  
$constant  CCU_DBG_WRITE_WP_HIT : $uint<8>:= 4  
$constant  CCU_TEU_CLEAR_BP : $uint<3>:= 2  
$constant  CCU_TEU_CLEAR_WP : $uint<3>:= 4  
$constant  CCU_TEU_INTR : $uint<3>:= 5  
$constant  CCU_TEU_SET_BP : $uint<3>:= 1  
$constant  CCU_TEU_SET_WP : $uint<3>:= 3  
$constant  CONTINUES_MISPREDICTED_STREAM : $uint<3>:= 4  
$constant  CONTINUES_TRAPPED_STREAM : $uint<3>:= 6  
$constant  CONTROL_TRANSFER_INSTR : $uint<3>:= 3  
$constant  CP_DISABLED_TRAP_BIT_VEC : $uint<32>:= 8192  
$constant  CP_DISABLED_TRAP_INDEX : $uint<32>:= 12  
$constant  CP_EXCEPTION_TRAP_BIT_VEC : $uint<32>:= 524288  
$constant  CP_EXCEPTION_TRAP_INDEX : $uint<32>:= 18  
$constant  CP_INSTR : $uint<3>:= 6  
$constant  DATA_ACCESS_ERROR_TRAP_BIT_VEC : $uint<32>:= 1048576  
$constant  DATA_ACCESS_ERROR_TRAP_INDEX : $uint<32>:= 19  
$constant  DATA_ACCESS_EXCEPTION_TRAP_BIT_VEC : $uint<32>:= 2097152  
$constant  DATA_ACCESS_EXCEPTION_TRAP_INDEX : $uint<32>:= 20  
$constant  DATA_STORE_ERROR_TRAP_BIT_VEC : $uint<32>:= 32  
$constant  DATA_STORE_ERROR_TRAP_INDEX : $uint<32>:= 5  
$constant  DATA_TRANSFER_INSTR : $uint<3>:= 1  
$constant  DEBUG_MODE_MASK : $uint<8>:= 2  
$constant  DENORM : $uint<1>:= _b1  
$constant  DIVISION_BY_ZERO_TRAP_BIT_VEC : $uint<32>:= 8388608  
$constant  DIVISION_BY_ZERO_TRAP_INDEX : $uint<32>:= 22  
$constant  DP_round_mid : $uint<10>:= _h200  
$constant  EXCEPTION_FOUND : $uint<8>:= 2  
$constant  FOUR_3 : $uint<3>:= 4  
$constant  FP_DISABLED_TRAP_BIT_VEC : $uint<32>:= 4096  
$constant  FP_DISABLED_TRAP_INDEX : $uint<32>:= 11  
$constant  FP_EXCEPTION_TRAP_BIT_VEC : $uint<32>:= 262144  
$constant  FP_EXCEPTION_TRAP_INDEX : $uint<32>:= 17  
$constant  FP_INSTR : $uint<3>:= 5  
$constant  FRACTION_WIDTH_23 : $uint<6>:= _b10111  
$constant  FRACTION_WIDTH_52 : $uint<6>:= _b110100  
$constant  ONE_1 : $uint<1>:= 1  
$constant  ONE_10 : $uint<10>:= 1  
$constant  ONE_11 : $uint<11>:= 1  
$constant  ONE_11_S : $int<11>:= _b11111111111  
$constant  ONE_12 : $uint<12>:= 1  
$constant  ONE_128 : $uint<128>:= 1  
$constant  ONE_13 : $uint<13>:= 1  
$constant  ONE_14 : $uint<14>:= 1  
$constant  ONE_16 : $uint<16>:= 1  
$constant  ONE_17 : $uint<17>:= 1  
$constant  ONE_18 : $uint<18>:= 1  
$constant  ONE_19 : $uint<19>:= 1  
$constant  ONE_2 : $uint<2>:= 1  
$constant  ONE_20 : $uint<20>:= 1  
$constant  ONE_23 : $uint<23>:= 1  
$constant  ONE_24 : $uint<24>:= 1  
$constant  ONE_25 : $uint<25>:= 1  
$constant  ONE_256 : $uint<256>:= 1  
$constant  ONE_29 : $uint<29>:= 1  
$constant  ONE_3 : $uint<3>:= 1  
$constant  ONE_31 : $uint<31>:= 1  
$constant  ONE_32 : $uint<32>:= 1  
$constant  ONE_36 : $uint<36>:= 1  
$constant  ONE_4 : $uint<4>:= 1  
$constant  ONE_48 : $uint<48>:= 1  
$constant  ONE_5 : $uint<5>:= 1  
$constant  ONE_52 : $uint<52>:= 1  
$constant  ONE_54 : $uint<54>:= _b1  
$constant  ONE_6 : $uint<6>:= 1  
$constant  ONE_62 : $uint<62>:= 1  
$constant  ONE_63 : $uint<63>:= 1  
$constant  ONE_64 : $uint<64>:= 1  
$constant  ONE_65 : $uint<65>:= _b1  
$constant  ONE_7 : $uint<7>:= 1  
$constant  ONE_8 : $uint<8>:= 1  
$constant  ONE_9 : $uint<9>:= 1  
$constant  SP_round_mid : $uint<39>:= _h4000000000  
$constant  THREE_2 : $uint<2>:= 3  
$constant  THREE_3 : $uint<3>:= 3  
$constant  TWO_2 : $uint<2>:= 2  
$constant  TWO_3 : $uint<3>:= 2  
$constant  ZERO_1 : $uint<1>:= 0  
$constant  ZERO_10 : $uint<10>:= 0  
$constant  ZERO_104 : $uint<104>:= 0  
$constant  ZERO_106 : $uint<106>:= _b0  
$constant  ZERO_11 : $uint<11>:= 0  
$constant  ZERO_12 : $uint<12>:= 0  
$constant  ZERO_128 : $uint<128>:= 0  
$constant  ZERO_13 : $uint<13>:= 0  
$constant  ZERO_14 : $uint<14>:= 0  
$constant  ZERO_16 : $uint<16>:= 0  
$constant  ZERO_17 : $uint<17>:= 0  
$constant  ZERO_18 : $uint<18>:= 0  
$constant  ZERO_19 : $uint<19>:= 0  
$constant  ZERO_2 : $uint<2>:= 0  
$constant  ZERO_20 : $uint<20>:= 0  
$constant  ZERO_22 : $uint<22>:= _b0  
$constant  ZERO_23 : $uint<23>:= 0  
$constant  ZERO_24 : $uint<24>:= 0  
$constant  ZERO_25 : $uint<25>:= 0  
$constant  ZERO_256 : $uint<256>:= 0  
$constant  ZERO_26 : $uint<26>:= 0  
$constant  ZERO_28 : $uint<28>:= 0  
$constant  ZERO_29 : $uint<29>:= 0  
$constant  ZERO_3 : $uint<3>:= 0  
$constant  ZERO_31 : $uint<31>:= 0  
$constant  ZERO_32 : $uint<32>:= 0  
$constant  ZERO_36 : $uint<36>:= 0  
$constant  ZERO_4 : $uint<4>:= 0  
$constant  ZERO_42 : $uint<42>:= _b0  
$constant  ZERO_48 : $uint<48>:= 0  
$constant  ZERO_5 : $uint<5>:= 0  
$constant  ZERO_51 : $uint<51>:= _b0  
$constant  ZERO_52 : $uint<52>:= 0  
$constant  ZERO_54 : $uint<54>:= _b0  
$constant  ZERO_55 : $uint<55>:= 0  
$constant  ZERO_6 : $uint<6>:= 0  
$constant  ZERO_61 : $uint<61>:= 0  
$constant  ZERO_62 : $uint<62>:= 0  
$constant  ZERO_63 : $uint<63>:= 0  
$constant  ZERO_64 : $uint<64>:= 0  
$constant  ZERO_7 : $uint<7>:= 0  
$constant  ZERO_8 : $uint<8>:= 0  
$constant  ZERO_9 : $uint<9>:= 0  
$constant  exp_base_0 : $int<13>:= _h00  
$constant  exp_base_1 : $int<13>:= _h01  
$constant  exp_base_1022 : $int<13>:= _h3fe  
$constant  exp_base_1023 : $int<13>:= _h3ff  
$constant  exp_base_126 : $int<13>:= _h7e  
$constant  exp_base_127 : $int<13>:= _h7f  
$constant  exp_base_24 : $int<13>:= _h18  
$constant  exp_base_254 : $int<13>:= _hfe  
$constant  exp_base_53 : $int<13>:= _h35  
$constant  exp_base_neg_1022 : $int<13>:= _h1C02  
$constant  exp_base_neg_126 : $int<13>:= _h1F82  
$constant  expbase_1022 : $int<13>:= _h3fe  
$constant  expbase_1023 : $int<13>:= _h3ff  
$constant  expbase_126 : $int<10>:= _h7e  
$constant  expbase_127 : $int<10>:= _h7f  
$constant  value_24 : $uint<7>:= _h18  
$constant  value_38 : $uint<6>:= _h26  
$constant  value_53 : $uint<7>:= _h35  
$constant  value_62 : $uint<6>:= _h3e  
$constant  value_9 : $uint<6>:= _h9  

$volatile $module [DoubleToExtendedFp]
$in ( uf1_d : $uint<64>   f1_d_class : $uint<10>  )
$out ( result : $uint<67>  )
$is
{
  sign_d := (uf1_d [] 63 ) $buffering 1
  exp_d := ( $slice uf1_d 62 52 )  $buffering 1
  mant_d := ( $slice uf1_d 51 0 )  $buffering 1
  f1_pos_normal := ( $slice f1_d_class 9 9 )  $buffering 1
  f1_neg_normal := ( $slice f1_d_class 8 8 )  $buffering 1
  f1_pos_denormal := ( $slice f1_d_class 7 7 )  $buffering 1
  f1_neg_denormal := ( $slice f1_d_class 6 6 )  $buffering 1
  f1_qnan := ( $slice f1_d_class 5 5 )  $buffering 1
  f1_snan := ( $slice f1_d_class 4 4 )  $buffering 1
  f1_pos_inf := ( $slice f1_d_class 3 3 )  $buffering 1
  f1_neg_inf := ( $slice f1_d_class 2 2 )  $buffering 1
  f1_pos_zero := ( $slice f1_d_class 1 1 )  $buffering 1
  f1_neg_zero := ( $slice f1_d_class 0 0 )  $buffering 1
  f1_normal := (f1_pos_normal | f1_neg_normal) $buffering 1
  f1_denormal := (f1_pos_denormal | f1_neg_denormal) $buffering 1
  f1_nan := (f1_qnan | f1_snan) $buffering 1
  f1_inf := (f1_pos_inf | f1_neg_inf) $buffering 1
  f1_zero := (f1_pos_zero | f1_neg_zero) $buffering 1
  bias := ( $mux f1_denormal exp_base_1022  exp_base_1023 )  $buffering 1
  exp_a := ($bitcast ($uint<13>) (($bitcast ($int<13>) exp_d ) - bias) ) $buffering 1
  man_52 := mant_d $buffering 1
  top_bit := (( ~ f1_denormal ) & ( ~ f1_zero )) $buffering 1
  result := ((sign_d && exp_a) && (top_bit && man_52)) $buffering 1
}

$volatile $module [classFpBase]
$in ( sign : $uint<1>   exp_all_ones : $uint<1>   exp_all_zeros : $uint<1>   mant_a_zero : $uint<1>   mant_top_bit : $uint<1>  )
$out ( pos_normal : $uint<1>   neg_normal : $uint<1>   pos_denormal : $uint<1>   neg_denormal : $uint<1>   qnan : $uint<1>   snan : $uint<1>   pos_inf : $uint<1>   neg_inf : $uint<1>   pos_zero : $uint<1>   neg_zero : $uint<1>  )
$is
{
  snan := ((exp_all_ones & ( ~ mant_a_zero )) & ( ~ mant_top_bit )) $buffering 1
  qnan := ((exp_all_ones & ( ~ mant_a_zero )) & mant_top_bit) $buffering 1
  pos_inf := ((exp_all_ones & mant_a_zero) & ( ~ sign )) $buffering 1
  neg_inf := ((exp_all_ones & mant_a_zero) & sign) $buffering 1
  pos_zero := ((exp_all_zeros & mant_a_zero) & ( ~ sign )) $buffering 1
  neg_zero := ((exp_all_zeros & mant_a_zero) & sign) $buffering 1
  pos_denormal := ((exp_all_zeros & ( ~ mant_a_zero )) & ( ~ sign )) $buffering 1
  neg_denormal := ((exp_all_zeros & ( ~ mant_a_zero )) & sign) $buffering 1
  pos_normal := ((( ~ exp_all_zeros ) & ( ~ exp_all_ones )) & ( ~ sign )) $buffering 1
  neg_normal := ((( ~ exp_all_zeros ) & ( ~ exp_all_ones )) & sign) $buffering 1
}

$volatile $module [classFp64]
$in ( a : $float<11,52>  )
$out ( pos_normal : $uint<1>   neg_normal : $uint<1>   pos_denormal : $uint<1>   neg_denormal : $uint<1>   qnan : $uint<1>   snan : $uint<1>   pos_inf : $uint<1>   neg_inf : $uint<1>   pos_zero : $uint<1>   neg_zero : $uint<1>  )
$is
{
  $report (fpunit_exec classFp64_input__ 	 a a )
  ua := ($bitcast ($uint<64>) a ) $buffering 1
  $report (fpunit_exec classFp64_trace__ 	 ua ua )
  sign := (ua [] 63 ) $buffering 1
  $report (fpunit_exec classFp64_trace__ 	 sign sign )
  exp_a := ( $slice ua 62 52 )  $buffering 1
  mant_a := ( $slice ua 51 0 )  $buffering 1
  $report (fpunit_exec classFp64_trace__ 	 exp_a exp_a 	 mant_a mant_a )
  exp_all_ones := (exp_a == ( ~ 0  )) $buffering 1
  exp_all_zeros := (exp_a == 0 ) $buffering 1
  $report (fpunit_exec classFp64_trace__ 	 exp_all_ones exp_all_ones 	 exp_all_zeros exp_all_zeros )
  mant_a_zero := (mant_a == 0 ) $buffering 1
  mant_top_bit := (mant_a [] 51 ) $buffering 1
  $report (fpunit_exec classFp64_trace__ 	 mant_a_zero mant_a_zero 	 mant_top_bit mant_top_bit )
  $volatile 	$call classFpBase (sign exp_all_ones exp_all_zeros mant_a_zero mant_top_bit ) (pos_normal neg_normal pos_denormal neg_denormal qnan snan pos_inf neg_inf pos_zero neg_zero ) 
}

$volatile $module [classify_64]
$in ( f1_d : $float<11,52>  )
$out ( f1_zero : $uint<1>   f1_normal : $uint<1>   f1_denormal : $uint<1>   f1_inf : $uint<1>   f1_nan : $uint<1>  )
$is
{
  $volatile 	$call classFp64 (f1_d ) (f1_d_pos_normal f1_d_neg_normal f1_d_pos_denormal f1_d_neg_denormal f1_d_qnan f1_d_snan f1_d_pos_inf f1_d_neg_inf f1_d_pos_zero f1_d_neg_zero ) 
  $volatile f1_zero := (f1_d_pos_zero | f1_d_neg_zero) $buffering 1
  $volatile f1_normal := (f1_d_pos_normal | f1_d_neg_normal) $buffering 1
  $volatile f1_denormal := (f1_d_pos_denormal | f1_d_neg_denormal) $buffering 1
  $volatile f1_inf := (f1_d_pos_inf | f1_d_neg_inf) $buffering 1
  $volatile f1_nan := (f1_d_snan | f1_d_qnan) $buffering 1
}

$volatile $module [find_left_4]
$in ( fp_4 : $uint<4>  )
$out ( position : $uint<2>   found : $uint<1>  )
$is
{
  $volatile x3 := ( $slice fp_4 3 3 )  $buffering 1
  $volatile x2 := ( $slice fp_4 2 2 )  $buffering 1
  $volatile x1 := ( $slice fp_4 1 1 )  $buffering 1
  $volatile x0 := ( $slice fp_4 0 0 )  $buffering 1
  $volatile found := ((x3 | x2) | (x1 | x0)) $buffering 1
  $volatile y1 := (x3 | x2) $buffering 1
  $volatile y0 := (x3 | (x1 & ( ~ x2 ))) $buffering 1
  $volatile position := (y1 && y0) $buffering 1
}

$volatile $module [find_left_8]
$in ( fp_8 : $uint<8>  )
$out ( position : $uint<3>   found : $uint<1>  )
$is
{
  $volatile fp_4_upper := ( $slice fp_8 7 4 )  $buffering 1
  $volatile fp_4_lower := ( $slice fp_8 3 0 )  $buffering 1
  $volatile 	$call find_left_4 (fp_4_upper ) (fp_4_upper_index found_upper ) 
  $volatile 	$call find_left_4 (fp_4_lower ) (fp_4_lower_index found_lower ) 
  $volatile position := ( $mux found_upper (ONE_1 && fp_4_upper_index)  ( $mux found_lower (ZERO_1 && fp_4_lower_index)  ZERO_3 )  )  $buffering 1
  $volatile found := (found_upper | found_lower) $buffering 1
}

$volatile $module [find_left_24]
$in ( fp_24 : $uint<24>  )
$out ( position : $uint<5>   found : $uint<1>  )
$is
{
  $volatile fp_2 := ( $slice fp_24 23 16 )  $buffering 1
  $volatile fp_1 := ( $slice fp_24 15 8 )  $buffering 1
  $volatile fp_0 := ( $slice fp_24 7 0 )  $buffering 1
  $volatile 	$call find_left_8 (fp_2 ) (pos_2 found_2 ) 
  $volatile 	$call find_left_8 (fp_1 ) (pos_1 found_1 ) 
  $volatile 	$call find_left_8 (fp_0 ) (pos_0 found_0 ) 
  found := ((found_2 | found_1) | found_0) $buffering 1
  position := ( $mux found_2 ((ONE_1 && ZERO_1) && pos_2)  ( $mux found_1 ((ZERO_1 && ONE_1) && pos_1)  ( $mux found_0 ((ZERO_1 && ZERO_1) && pos_0)  0  )  )  )  $buffering 1
}

$volatile $module [find_left_53]
$in ( fp_53 : $uint<53>  )
$out ( position : $uint<6>   found : $uint<1>  )
$is
{
  $volatile fp_3 := ( $slice fp_53 52 52 )  $buffering 1
  $volatile fp_2 := ( $slice fp_53 51 48 )  $buffering 1
  $volatile fp_1 := ( $slice fp_53 47 24 )  $buffering 1
  $volatile fp_0 := ( $slice fp_53 23 0 )  $buffering 1
  $volatile 	$call find_left_4 (fp_2 ) (pos_2 found_2 ) 
  $volatile 	$call find_left_24 (fp_1 ) (pos_1 found_1 ) 
  $volatile 	$call find_left_24 (fp_0 ) (pos_0 found_0 ) 
  found := ((fp_3 | found_2) | (found_1 | found_0)) $buffering 1
  position := ( $mux fp_3 52   ( $mux found_2 (($bitcast ($uint<6>) pos_2 ) + 48 )  ( $mux found_1 (($bitcast ($uint<6>) pos_1 ) + 24 )  ( $mux found_0 ($bitcast ($uint<6>) pos_0 )  0  )  )  )  )  $buffering 1
}

$volatile $module [i53_sll]
$in ( X : $uint<53>   S : $uint<6>  )
$out ( Y : $uint<53>  )
$is
{
  X0 := ( $mux (S [] 0 ) (( $slice X 51 0 )  && ZERO_1)  X )  $buffering 1
  X1 := ( $mux (S [] 1 ) (( $slice X0 50 0 )  && ZERO_2)  X0 )  $buffering 1
  X2 := ( $mux (S [] 2 ) (( $slice X1 48 0 )  && ZERO_4)  X1 )  $buffering 1
  X3 := ( $mux (S [] 3 ) (( $slice X2 44 0 )  && ZERO_8)  X2 )  $buffering 1
  X4 := ( $mux (S [] 4 ) (( $slice X3 36 0 )  && ZERO_16)  X3 )  $buffering 1
  Y := ( $mux (S [] 5 ) (( $slice X4 20 0 )  && ZERO_32)  X4 )  $buffering 1
}

$pipeline $depth 3 $buffering 1 $fullrate $deterministic $operator $module [DoubleToSingle]
$in ( f1_d : $float<11,52>  )
$out ( needs_norm : $uint<1>   extn_result : $uint<81>  )
$is
{
  $volatile uf1_d := ($bitcast ($uint<64>) f1_d ) $buffering 1
  $volatile sign_d := (uf1_d [] 63 ) $buffering 1
  $volatile exp_d := ( $slice uf1_d 62 52 )  $buffering 1
  $volatile mant_d := ( $slice uf1_d 51 0 )  $buffering 1
  $volatile 	$call classify_64 (f1_d ) (f1_zero f1_normal f1_denormal f1_inf f1_nan ) 
  $volatile bias := ( $mux f1_denormal exp_base_1022  exp_base_1023 )  $buffering 1
  $volatile exp_without_bias := (($bitcast ($int<13>) exp_d ) - bias) $buffering 1
  $volatile mantissa_msb := ( $mux f1_denormal ZERO_1  ONE_1 )  $buffering 1
  $volatile mantissa_53_bits := (mantissa_msb && mant_d) $buffering 1
  $volatile 	$call find_left_53 (mantissa_53_bits ) (top_bit_pos top_bit_found ) 
  shift_amount := (52  - top_bit_pos) $buffering 1// bits of buffering = 6. 
  $volatile 	$call i53_sll (mantissa_53_bits shift_amount ) (mantissa_53_aligned ) 
  $volatile exp_without_bias_adjusted := (exp_without_bias - ($bitcast ($int<13>) shift_amount )) $buffering 1
  $volatile overflow := (exp_without_bias_adjusted > 127 ) $buffering 1
  $volatile underflow := (exp_without_bias_adjusted < (0  - 126 )) $buffering 1
  $volatile mantissa_62 := (( $slice mantissa_53_aligned 51 0 )  && ZERO_10) $buffering 1
  $volatile exponent_to_be_passed := ((( $mux f1_nan ALL_ONE_13  _b0  )  | ( $mux (f1_inf | overflow) ALL_ONE_13  _b0  ) ) | (( $mux f1_zero ($bitcast ($int<13>) ZERO_13 )  _b0  )  | ( $mux (( ~ overflow ) & (f1_normal | f1_denormal)) exp_without_bias_adjusted  _b0  ) )) $buffering 1
  $volatile mantissa_to_be_passed := ((( $mux f1_nan (ONE_1 && ZERO_61)  _b0  )  | ( $mux (f1_inf | overflow) ZERO_62  _b0  ) ) | (( $mux f1_zero ZERO_62  _b0  )  | ( $mux (( ~ overflow ) & (f1_normal | f1_denormal)) mantissa_62  _b0  ) )) $buffering 1
  needs_norm := (((underflow & ( ~ f1_nan )) & ( ~ f1_inf )) & (( ~ f1_zero ) & ( ~ overflow ))) $buffering 1// bits of buffering = 1. 
  extn_result := (((ZERO_1 && ZERO_1) && (sign_d && f1_nan)) && (((f1_inf | overflow) && f1_zero) && (($bitcast ($uint<13>) exponent_to_be_passed ) && mantissa_to_be_passed))) $buffering 1// bits of buffering = 81. 
  $attribute delay 2
}

$volatile $module [classFp32]
$in ( a : $float<8,23>  )
$out ( pos_normal : $uint<1>   neg_normal : $uint<1>   pos_denormal : $uint<1>   neg_denormal : $uint<1>   qnan : $uint<1>   snan : $uint<1>   pos_inf : $uint<1>   neg_inf : $uint<1>   pos_zero : $uint<1>   neg_zero : $uint<1>  )
$is
{
  ua := ($bitcast ($uint<32>) a ) $buffering 1
  sign := (ua [] 31 ) $buffering 1
  exp_a := ( $slice ua 30 23 )  $buffering 1
  mant_a := ( $slice ua 22 0 )  $buffering 1
  exp_all_ones := (exp_a == ( ~ 0  )) $buffering 1
  exp_all_zeros := (exp_a == 0 ) $buffering 1
  mant_a_zero := (mant_a == 0 ) $buffering 1
  mant_top_bit := (mant_a [] 22 ) $buffering 1
  $volatile 	$call classFpBase (sign exp_all_ones exp_all_zeros mant_a_zero mant_top_bit ) (pos_normal neg_normal pos_denormal neg_denormal qnan snan pos_inf neg_inf pos_zero neg_zero ) 
  $report (fpunit_exec classFp32_trace__ 	 ua ua 	 sign sign 	 exp_a exp_a 	 mant_a mant_a 	 exp_all_ones exp_all_ones 	 exp_all_zeros exp_all_zeros 	 mant_a_zero mant_a_zero 	 mant_top_bit mant_top_bit 	 qnan qnan 	 snan snan )
}

$volatile $module [classify_32]
$in ( f1_s : $float<8,23>  )
$out ( f1_zero : $uint<1>   f1_normal : $uint<1>   f1_denormal : $uint<1>   f1_inf : $uint<1>   f1_nan : $uint<1>  )
$is
{
  $volatile 	$call classFp32 (f1_s ) (f1_s_pos_normal f1_s_neg_normal f1_s_pos_denormal f1_s_neg_denormal f1_s_qnan f1_s_snan f1_s_pos_inf f1_s_neg_inf f1_s_pos_zero f1_s_neg_zero ) 
  $volatile f1_zero := (f1_s_pos_zero | f1_s_neg_zero) $buffering 1
  $volatile f1_normal := (f1_s_pos_normal | f1_s_neg_normal) $buffering 1
  $volatile f1_denormal := (f1_s_pos_denormal | f1_s_neg_denormal) $buffering 1
  $volatile f1_inf := (f1_s_pos_inf | f1_s_neg_inf) $buffering 1
  $volatile f1_nan := (f1_s_snan | f1_s_qnan) $buffering 1
}

$volatile $module [i24_sll]
$in ( X : $uint<24>   S : $uint<5>  )
$out ( Y : $uint<24>  )
$is
{
  X0 := ( $mux (S [] 0 ) (( $slice X 22 0 )  && ZERO_1)  X )  $buffering 1
  X1 := ( $mux (S [] 1 ) (( $slice X0 21 0 )  && ZERO_2)  X0 )  $buffering 1
  X2 := ( $mux (S [] 2 ) (( $slice X1 19 0 )  && ZERO_4)  X1 )  $buffering 1
  X3 := ( $mux (S [] 3 ) (( $slice X2 15 0 )  && ZERO_8)  X2 )  $buffering 1
  Y := ( $mux (S [] 4 ) (( $slice X3 7 0 )  && ZERO_16)  X3 )  $buffering 1
}

$volatile $module [SingleToDouble]
$in ( f1_s : $float<8,23>  )
$out ( f1_d : $float<11,52>  )
$is
{
  $volatile uf1_s := ($bitcast ($uint<32>) f1_s ) $buffering 1
  $volatile sign_s := (uf1_s [] 31 ) $buffering 1
  $volatile exp_s := ( $slice uf1_s 30 23 )  $buffering 1
  $volatile mant_s := ( $slice uf1_s 22 0 )  $buffering 1
  $volatile 	$call classify_32 (f1_s ) (f1_zero f1_normal f1_denormal f1_inf f1_nan ) 
  $volatile mantissa_msb := ( $mux f1_denormal ZERO_1  ONE_1 )  $buffering 1
  $volatile frac := (mantissa_msb && mant_s) $buffering 1
  $volatile bias := ( $mux f1_denormal exp_base_126  exp_base_127 )  $buffering 1
  $volatile exp_a := (($bitcast ($int<13>) exp_s ) - bias) $buffering 1
  $volatile 	$call find_left_24 (frac ) (position found ) 
  $volatile left_shifts_required := (23  - position) $buffering 1
  $volatile 	$call i24_sll (frac left_shifts_required ) (frac_shifted ) 
  $volatile expon_normalized := (exp_a - ($bitcast ($int<13>) left_shifts_required )) $buffering 1
  $volatile exp_11 := ($bitcast ($uint<11>) (expon_normalized + exp_base_1023) ) $buffering 1
  $volatile man_52 := (( $slice frac_shifted 22 0 )  && ZERO_29) $buffering 1
  $volatile result_norm_denorm := ((sign_s && exp_11) && man_52) $buffering 1
  $volatile result_qnan := ((ZERO_1 && ALL_ONE_11) && (ONE_1 && ZERO_51)) $buffering 1
  $volatile result_zero := (sign_s && ZERO_63) $buffering 1
  $volatile result_infinity := ((sign_s && ALL_ONE_11) && ZERO_52) $buffering 1
  $volatile result := ((( $mux (f1_normal | f1_denormal) result_norm_denorm  _b0  )  | ( $mux f1_nan result_qnan  _b0  ) ) | (( $mux f1_zero result_zero  _b0  )  | ( $mux f1_inf result_infinity  _b0  ) )) $buffering 1
  $volatile f1_d := ($bitcast ($float<11,52>) result ) $buffering 1
}

$volatile $module [SingleToExtendedFp]
$in ( uf1_s : $uint<32>   f1_s_class : $uint<10>  )
$out ( result : $uint<67>  )
$is
{
  $report (fpunit_exec SingleToExtendedFp_in_args 	 uf1_s uf1_s 	 f1_s_class f1_s_class )
  sign_s := (uf1_s [] 31 ) $buffering 1
  exp_s := ( $slice uf1_s 30 23 )  $buffering 1
  mant_s := ( $slice uf1_s 22 0 )  $buffering 1
  f1_pos_normal := ( $slice f1_s_class 9 9 )  $buffering 1
  f1_neg_normal := ( $slice f1_s_class 8 8 )  $buffering 1
  f1_pos_denormal := ( $slice f1_s_class 7 7 )  $buffering 1
  f1_neg_denormal := ( $slice f1_s_class 6 6 )  $buffering 1
  f1_qnan := ( $slice f1_s_class 5 5 )  $buffering 1
  f1_snan := ( $slice f1_s_class 4 4 )  $buffering 1
  f1_pos_inf := ( $slice f1_s_class 3 3 )  $buffering 1
  f1_neg_inf := ( $slice f1_s_class 2 2 )  $buffering 1
  f1_pos_zero := ( $slice f1_s_class 1 1 )  $buffering 1
  f1_neg_zero := ( $slice f1_s_class 0 0 )  $buffering 1
  f1_normal := (f1_pos_normal | f1_neg_normal) $buffering 1
  f1_denormal := (f1_pos_denormal | f1_neg_denormal) $buffering 1
  f1_nan := (f1_qnan | f1_snan) $buffering 1
  f1_inf := (f1_pos_inf | f1_neg_inf) $buffering 1
  f1_zero := (f1_pos_zero | f1_neg_zero) $buffering 1
  bias := ( $mux f1_denormal exp_base_126  exp_base_127 )  $buffering 1
  $report (fpunit_exec SingleToExtendedFp_bias 	 f1_denormal f1_denormal 	 exp_base_126 exp_base_126 	 exp_base_127 exp_base_127 	 bias bias )
  top_bit := (( ~ f1_denormal ) & ( ~ f1_zero )) $buffering 1
  exp_a := ($bitcast ($uint<13>) (($bitcast ($int<13>) exp_s ) - bias) ) $buffering 1
  man_52 := (mant_s && ZERO_29) $buffering 1
  $report (fpunit_exec SingleToExtendedFp_extended_result 	 exp_s exp_s 	 bias bias 	 exp_a exp_a 	 man_52 man_52 )
  result := ((sign_s && exp_a) && (top_bit && man_52)) $buffering 1
}

$volatile $module [absVal]
$in ( a : $uint<16>  )
$out ( ret_val : $uint<16>  )
$is
{
  ret_val := (ZERO_1 && ( $slice a 14 0 ) ) $buffering 1
}

$volatile $module [adder_11]
$in ( A : $uint<10>   B : $uint<10>   CIN : $uint<1>  )
$out ( SUM : $uint<10>   COUT : $uint<1>  )
$is
{
  $volatile operand_A := ((ZERO_1 && A) && CIN) $buffering 1
  $volatile operand_B := ((ZERO_1 && B) && CIN) $buffering 1
  $volatile add_result := (operand_A + operand_B) $buffering 1
  $volatile SUM := ( $slice add_result 10 1 )  $buffering 1
  $volatile COUT := (add_result [] 11 ) $buffering 1
}

$volatile $module [adder_18]
$in ( A : $uint<16>   B : $uint<16>   CIN : $uint<1>  )
$out ( SUM : $uint<16>   COUT : $uint<1>  )
$is
{
  $volatile operand_A := ((ZERO_1 && A) && CIN) $buffering 1
  $volatile operand_B := ((ZERO_1 && B) && CIN) $buffering 1
  $volatile add_result := (operand_A + operand_B) $buffering 1
  $volatile SUM := ( $slice add_result 16 1 )  $buffering 1
  $volatile COUT := (add_result [] 17 ) $buffering 1
}

$volatile $module [adder_19]
$in ( A : $uint<17>   B : $uint<17>   CIN : $uint<1>  )
$out ( SUM : $uint<17>   COUT : $uint<1>  )
$is
{
  $volatile operand_A := ((ZERO_1 && A) && CIN) $buffering 1
  $volatile operand_B := ((ZERO_1 && B) && CIN) $buffering 1
  $volatile add_result := (operand_A + operand_B) $buffering 1
  $volatile SUM := ( $slice add_result 17 1 )  $buffering 1
  $volatile COUT := (add_result [] 18 ) $buffering 1
}

$volatile $module [adder_35_with_carry]
$in ( A : $uint<35>   B : $uint<35>   CIN : $uint<1>  )
$out ( SUM : $uint<35>   COUT : $uint<1>  )
$is
{
  S37 := (((ZERO_1 && A) && CIN) + ((ZERO_1 && B) && CIN)) $buffering 1
  SUM := ( $slice S37 35 1 )  $buffering 1
  COUT := (S37 [] 36 ) $buffering 1
}

$volatile $module [adder_58_with_carry]
$in ( A : $uint<58>   B : $uint<58>   CIN : $uint<1>  )
$out ( SUM : $uint<58>   COUT : $uint<1>  )
$is
{
  $volatile A0 := ( $slice A 15 0 )  $buffering 1
  $volatile A1 := ( $slice A 31 16 )  $buffering 1
  $volatile A2 := ( $slice A 47 32 )  $buffering 1
  $volatile A3 := ( $slice A 57 48 )  $buffering 1
  $volatile B0 := ( $slice B 15 0 )  $buffering 1
  $volatile B1 := ( $slice B 31 16 )  $buffering 1
  $volatile B2 := ( $slice B 47 32 )  $buffering 1
  $volatile B3 := ( $slice B 57 48 )  $buffering 1
  $volatile 	$call adder_18 (A0 B0 CIN ) (CIN0_S0 CIN0_C0 ) 
  $volatile 	$call adder_18 (A1 B1 ZERO_1 ) (CIN0_S1 CIN0_C1 ) 
  $volatile 	$call adder_18 (A1 B1 ONE_1 ) (CIN1_S1 CIN1_C1 ) 
  $volatile 	$call adder_18 (A2 B2 ZERO_1 ) (CIN0_S2 CIN0_C2 ) 
  $volatile 	$call adder_18 (A2 B2 ONE_1 ) (CIN1_S2 CIN1_C2 ) 
  $volatile 	$call adder_11 (A3 B3 ZERO_1 ) (CIN0_S3 CIN0_C3 ) 
  $volatile 	$call adder_11 (A3 B3 ONE_1 ) (CIN1_S3 CIN1_C3 ) 
  $volatile sum_0 := CIN0_S0 $buffering 1
  $volatile carry_0 := CIN0_C0 $buffering 1
  $volatile sum_1 := ( $mux carry_0 CIN1_S1  CIN0_S1 )  $buffering 1
  $volatile carry_1 := ( $mux carry_0 CIN1_C1  CIN0_C1 )  $buffering 1
  $volatile sum_2 := ( $mux carry_1 CIN1_S2  CIN0_S2 )  $buffering 1
  $volatile carry_2 := ( $mux carry_1 CIN1_C2  CIN0_C2 )  $buffering 1
  $volatile sum_3 := ( $mux carry_2 CIN1_S3  CIN0_S3 )  $buffering 1
  $volatile carry_3 := ( $mux carry_2 CIN1_C3  CIN0_C3 )  $buffering 1
  SUM := ((sum_3 && sum_2) && (sum_1 && sum_0)) $buffering 1
  COUT := carry_3 $buffering 1
}

$volatile $module [adder_64_with_carry]
$in ( A : $uint<64>   B : $uint<64>   CIN : $uint<1>  )
$out ( SUM : $uint<64>   COUT : $uint<1>  )
$is
{
  $volatile A0 := ( $slice A 15 0 )  $buffering 1
  $volatile A1 := ( $slice A 31 16 )  $buffering 1
  $volatile A2 := ( $slice A 47 32 )  $buffering 1
  $volatile A3 := ( $slice A 63 48 )  $buffering 1
  $volatile B0 := ( $slice B 15 0 )  $buffering 1
  $volatile B1 := ( $slice B 31 16 )  $buffering 1
  $volatile B2 := ( $slice B 47 32 )  $buffering 1
  $volatile B3 := ( $slice B 63 48 )  $buffering 1
  $volatile 	$call adder_18 (A0 B0 CIN ) (CIN0_S0 CIN0_C0 ) 
  $volatile 	$call adder_18 (A1 B1 ZERO_1 ) (CIN0_S1 CIN0_C1 ) 
  $volatile 	$call adder_18 (A1 B1 ONE_1 ) (CIN1_S1 CIN1_C1 ) 
  $volatile 	$call adder_18 (A2 B2 ZERO_1 ) (CIN0_S2 CIN0_C2 ) 
  $volatile 	$call adder_18 (A2 B2 ONE_1 ) (CIN1_S2 CIN1_C2 ) 
  $volatile 	$call adder_18 (A3 B3 ZERO_1 ) (CIN0_S3 CIN0_C3 ) 
  $volatile 	$call adder_18 (A3 B3 ONE_1 ) (CIN1_S3 CIN1_C3 ) 
  $volatile sum_0 := CIN0_S0 $buffering 1
  $volatile carry_0 := CIN0_C0 $buffering 1
  $volatile sum_1 := ( $mux carry_0 CIN1_S1  CIN0_S1 )  $buffering 1
  $volatile carry_1 := ( $mux carry_0 CIN1_C1  CIN0_C1 )  $buffering 1
  $volatile sum_2 := ( $mux carry_1 CIN1_S2  CIN0_S2 )  $buffering 1
  $volatile carry_2 := ( $mux carry_1 CIN1_C2  CIN0_C2 )  $buffering 1
  $volatile sum_3 := ( $mux carry_2 CIN1_S3  CIN0_S3 )  $buffering 1
  $volatile carry_3 := ( $mux carry_2 CIN1_C3  CIN0_C3 )  $buffering 1
  SUM := ((sum_3 && sum_2) && (sum_1 && sum_0)) $buffering 1
  COUT := carry_3 $buffering 1
}

$volatile $module [adder_65]
$in ( A : $uint<65>   B : $uint<65>  )
$out ( SUM : $uint<65>  )
$is
{
  $volatile A0 := ( $slice A 15 0 )  $buffering 1
  $volatile A1 := ( $slice A 31 16 )  $buffering 1
  $volatile A2 := ( $slice A 47 32 )  $buffering 1
  $volatile A3 := ( $slice A 64 48 )  $buffering 1
  $volatile B0 := ( $slice B 15 0 )  $buffering 1
  $volatile B1 := ( $slice B 31 16 )  $buffering 1
  $volatile B2 := ( $slice B 47 32 )  $buffering 1
  $volatile B3 := ( $slice B 64 48 )  $buffering 1
  $volatile 	$call adder_18 (A0 B0 ZERO_1 ) (CIN0_S0 CIN0_C0 ) 
  $volatile 	$call adder_18 (A1 B1 ZERO_1 ) (CIN0_S1 CIN0_C1 ) 
  $volatile 	$call adder_18 (A1 B1 ONE_1 ) (CIN1_S1 CIN1_C1 ) 
  $volatile 	$call adder_18 (A2 B2 ZERO_1 ) (CIN0_S2 CIN0_C2 ) 
  $volatile 	$call adder_18 (A2 B2 ONE_1 ) (CIN1_S2 CIN1_C2 ) 
  $volatile 	$call adder_19 (A3 B3 ZERO_1 ) (CIN0_S3 CIN0_C3 ) 
  $volatile 	$call adder_19 (A3 B3 ONE_1 ) (CIN1_S3 CIN1_C3 ) 
  $volatile sum_0 := CIN0_S0 $buffering 1
  $volatile carry_0 := CIN0_C0 $buffering 1
  $volatile sum_1 := ( $mux carry_0 CIN1_S1  CIN0_S1 )  $buffering 1
  $volatile carry_1 := ( $mux carry_0 CIN1_C1  CIN0_C1 )  $buffering 1
  $volatile sum_2 := ( $mux carry_1 CIN1_S2  CIN0_S2 )  $buffering 1
  $volatile carry_2 := ( $mux carry_1 CIN1_C2  CIN0_C2 )  $buffering 1
  $volatile sum_3 := ( $mux carry_2 CIN1_S3  CIN0_S3 )  $buffering 1
  $volatile carry_3 := ( $mux carry_2 CIN1_C3  CIN0_C3 )  $buffering 1
  SUM := ((sum_3 && sum_2) && (sum_1 && sum_0)) $buffering 1
}

$volatile $module [find_left_16]
$in ( fp_16 : $uint<16>  )
$out ( position : $uint<4>   found : $uint<1>  )
$is
{
  $volatile fp_8_upper := ( $slice fp_16 15 8 )  $buffering 1
  $volatile fp_8_lower := ( $slice fp_16 7 0 )  $buffering 1
  $volatile 	$call find_left_8 (fp_8_upper ) (fp_8_upper_index found_upper ) 
  $volatile 	$call find_left_8 (fp_8_lower ) (fp_8_lower_index found_lower ) 
  $volatile position := ( $mux found_upper (ONE_1 && fp_8_upper_index)  ( $mux found_lower (ZERO_1 && fp_8_lower_index)  ZERO_4 )  )  $buffering 1
  $volatile found := (found_upper | found_lower) $buffering 1
}

$volatile $module [find_left_32]
$in ( fp_32 : $uint<32>  )
$out ( position : $uint<5>   found : $uint<1>  )
$is
{
  $volatile fp_16_upper := ( $slice fp_32 31 16 )  $buffering 1
  $volatile fp_16_lower := ( $slice fp_32 15 0 )  $buffering 1
  $volatile 	$call find_left_16 (fp_16_upper ) (fp_16_upper_index found_upper ) 
  $volatile 	$call find_left_16 (fp_16_lower ) (fp_16_lower_index found_lower ) 
  $volatile position := ( $mux found_upper (ONE_1 && fp_16_upper_index)  ( $mux found_lower (ZERO_1 && fp_16_lower_index)  ZERO_5 )  )  $buffering 1
  $volatile found := (found_upper | found_lower) $buffering 1
}

$volatile $module [find_leftmost_64]
$in ( fp_64 : $uint<64>  )
$out ( position : $uint<6>   found : $uint<1>  )
$is
{
  $volatile fp_32_upper := ( $slice fp_64 63 32 )  $buffering 1
  $volatile fp_32_lower := ( $slice fp_64 31 0 )  $buffering 1
  $volatile 	$call find_left_32 (fp_32_upper ) (fp_32_upper_index found_upper ) 
  $volatile 	$call find_left_32 (fp_32_lower ) (fp_32_lower_index found_lower ) 
  $volatile position := ( $mux found_upper (ONE_1 && fp_32_upper_index)  ( $mux found_lower (ZERO_1 && fp_32_lower_index)  ZERO_6 )  )  $buffering 1
  $volatile found := (found_upper | found_lower) $buffering 1
}

$volatile $module [u_cmp_32]
$in ( a : $uint<32>   b : $uint<32>  )
$out ( l : $uint<1>   g : $uint<1>   e : $uint<1>  )
$is
{
  al := ( $slice a 15 0 )  $buffering 1
  ah := ( $slice a 31 16 )  $buffering 1
  bl := ( $slice b 15 0 )  $buffering 1
  bh := ( $slice b 31 16 )  $buffering 1
  ll := (al < bl) $buffering 1
  gl := (al > bl) $buffering 1
  el := (al == bl) $buffering 1
  lh := (ah < bh) $buffering 1
  gh := (ah > bh) $buffering 1
  eh := (ah == bh) $buffering 1
  l := (lh | (eh & ll)) $buffering 1
  e := (eh & el) $buffering 1
  g := (gh | (eh & gl)) $buffering 1
}

$volatile $module [u_cmp_64]
$in ( a : $uint<64>   b : $uint<64>  )
$out ( l : $uint<1>   g : $uint<1>   e : $uint<1>  )
$is
{
  al := ( $slice a 31 0 )  $buffering 1
  ah := ( $slice a 63 32 )  $buffering 1
  bl := ( $slice b 31 0 )  $buffering 1
  bh := ( $slice b 63 32 )  $buffering 1
  $volatile 	$call u_cmp_32 (al bl ) (ll gl el ) 
  $volatile 	$call u_cmp_32 (ah bh ) (lh gh eh ) 
  l := (lh | (eh & ll)) $buffering 1
  e := (eh & el) $buffering 1
  g := (gh | (eh & gl)) $buffering 1
}

$volatile $module [u_set_index_64]
$in ( idx : $uint<6>  )
$out ( x : $uint<64>  )
$is
{
  idx_16 := ($bitcast ($uint<16>) idx ) $buffering 1
  x00 := (($bitcast ($uint<16>) 1  ) << idx_16) $buffering 1
  x01 := ( $mux (idx_16 >= 16 ) (($bitcast ($uint<16>) 1  ) << (idx_16 - 16 ))  ZERO_16 )  $buffering 1
  x10 := ( $mux (idx_16 >= 32 ) (($bitcast ($uint<16>) 1  ) << (idx_16 - 32 ))  ZERO_16 )  $buffering 1
  x11 := ( $mux (idx_16 >= 48 ) (($bitcast ($uint<16>) 1  ) << (idx_16 - 48 ))  ZERO_16 )  $buffering 1
  x := ((x11 && x10) && (x01 && x00)) $buffering 1
}

$pipeline $depth 3 $buffering 1 $fullrate $operator $module [alignDivisorToDividend]
$in ( DIVIDEND : $uint<64>   udivisor : $uint<64>  )
$out ( SSD : $uint<64>   CCQ : $uint<64>  )
$is
{
  $volatile 	$call find_leftmost_64 (DIVIDEND ) (l_DIVIDEND z_DIVIDEND ) 
  $volatile 	$call find_leftmost_64 (udivisor ) (l_udivisor z_udivisor ) 
  $assert (udivisor > 0 ) $report (iu_exec alignDivisorToDividend__udivisor_Is_Zero )
  $volatile shift_amount := (l_DIVIDEND - l_udivisor) $buffering 1
  shifted_udivisor := (udivisor << ($bitcast ($uint<64>) shift_amount )) $buffering 1// bits of buffering = 64. 
  $volatile 	$call u_cmp_64 (shifted_udivisor DIVIDEND ) (l g e ) 
  $volatile shift_ok := (l | e) $buffering 1
  $volatile ccq_shift_amount := ( $mux shift_ok ($bitcast ($uint<6>) shift_amount )  ($bitcast ($uint<6>) (shift_amount - 1 ) ) )  $buffering 1
  $volatile 	$call u_set_index_64 (ccq_shift_amount ) (ccq_v ) 
  CCQ := ccq_v $buffering 1// bits of buffering = 64. 
  SSD := ( $mux shift_ok shifted_udivisor  (ZERO_1 && ( $slice shifted_udivisor 63 1 ) ) )  $buffering 1// bits of buffering = 64. 
  $attribute output_buffering 0
}

$volatile $module [analyze_sc_annul_status]
$in ( thread_head : $uint<1>   stream_head : $uint<1>   thread_id : $uint<4>   stream_id : $uint<2>   sc_annul_status : $uint<16>  )
$out ( sc_annul_apply : $uint<1>   sc_annul_value : $uint<1>  )
$is
{
  terminates_stream := ( $slice sc_annul_status 15 15 )  $buffering 1
  last_was_cti := ( $slice sc_annul_status 14 14 )  $buffering 1
  is_cti := ( $slice sc_annul_status 13 13 )  $buffering 1
  annul_next := ( $slice sc_annul_status 12 12 )  $buffering 1
  tid := ( $slice sc_annul_status 11 8 )  $buffering 1
  sid := ( $slice sc_annul_status 7 6 )  $buffering 1
  slot_id := ( $slice sc_annul_status 5 0 )  $buffering 1
  sc_annul_apply := (((terminates_stream & stream_head) & ( ~ thread_head )) & ((stream_id == (sid + 1 )) & (thread_id == tid))) $buffering 1
  sc_annul_value := annul_next $buffering 1
  $report (idecode analyze_sc_annul_status 	 thread_id thread_id 	 stream_id stream_id 	 tid tid 	 sid sid 	 slot_id slot_id 	 terminates_stream terminates_stream 	 last_was_cti last_was_cti 	 is_cti is_cti 	 annul_next annul_next 	 sc_annul_apply sc_annul_apply 	 sc_annul_value sc_annul_value )
}

$volatile $module [break_number_32]
$in ( fp : $uint<32>   normal : $uint<1>   denormal : $uint<1>   qnan : $uint<1>   snan : $uint<1>   inf : $uint<1>   zero : $uint<1>   denormalize : $uint<1>  )
$out ( fract : $uint<24>   expon : $int<10>  )
$is
{
  $volatile fraction := ( $slice fp 22 0 )  $buffering 1
  $volatile exponent := ( $slice fp 30 23 )  $buffering 1
  $volatile exponent_signed := ($bitcast ($int<10>) exponent ) $buffering 1
  $volatile cond := (denormal & denormalize) $buffering 1
  $volatile fract_temp := (( $mux (zero | (denormal & denormalize)) (ZERO_1 && fraction)  _b0  )  | ( $mux ((((denormal & ( ~ denormalize )) | normal) | inf) | (qnan | snan)) (ONE_1 && fraction)  _b0  ) ) $buffering 1
  $volatile expo_base := ((( $mux (denormal & denormalize) expbase_126  _b0  )  | ( $mux ((((denormal & ( ~ denormalize )) | normal) | inf) | (qnan | snan)) expbase_127  _b0  ) ) | ( $mux zero exponent_signed  _b0  ) ) $buffering 1
  expon := (exponent_signed - expo_base) $buffering 1
  fract := fract_temp $buffering 1
}

$volatile $module [break_number_64]
$in ( fp : $uint<64>   normal : $uint<1>   denormal : $uint<1>   qnan : $uint<1>   snan : $uint<1>   inf : $uint<1>   zero : $uint<1>   denormalize : $uint<1>  )
$out ( fract : $uint<53>   expon : $int<13>  )
$is
{
  $volatile fraction := ( $slice fp 51 0 )  $buffering 1
  $volatile exponent := ( $slice fp 62 52 )  $buffering 1
  $volatile exponent_signed := ($bitcast ($int<13>) exponent ) $buffering 1
  $volatile cond := (denormal & denormalize) $buffering 1
  $volatile fract_temp := (( $mux (zero | (denormal & denormalize)) (ZERO_1 && fraction)  _b0  )  | ( $mux ((((denormal & ( ~ denormalize )) | normal) | inf) | (qnan | snan)) (ONE_1 && fraction)  _b0  ) ) $buffering 1
  $volatile expo_base := ((( $mux (denormal & denormalize) expbase_1022  _b0  )  | ( $mux ((((denormal & ( ~ denormalize )) | normal) | inf) | (qnan | snan)) expbase_1023  _b0  ) ) | ( $mux zero exponent_signed  _b0  ) ) $buffering 1
  expon := (exponent_signed - expo_base) $buffering 1
  fract := fract_temp $buffering 1
}

$volatile $module [check_fh_exponent_overflow]
$in ( exp_ab : $int<7>  )
$out ( overflow : $uint<1>   underflow : $uint<1>  )
$is
{
  exponent_ext := (exp_ab + 15) $buffering 1
  overflow := (exp_ab > 16) $buffering 1
  underflow := (exp_ab < -15) $buffering 1
}

$volatile $module [classFp32IntoClassWord]
$in ( f1_s : $float<8,23>  )
$out ( f1_s_classification : $uint<10>  )
$is
{
  $volatile 	$call classFp32 (f1_s ) (f1_s_pos_normal f1_s_neg_normal f1_s_pos_denormal f1_s_neg_denormal f1_s_qnan f1_s_snan f1_s_pos_inf f1_s_neg_inf f1_s_pos_zero f1_s_neg_zero ) 
  f1_s_classification := ((((f1_s_pos_normal && f1_s_neg_normal) && f1_s_pos_denormal) && (f1_s_neg_denormal && f1_s_qnan)) && (((f1_s_snan && f1_s_pos_inf) && f1_s_neg_inf) && (f1_s_pos_zero && f1_s_neg_zero))) $buffering 1
}

$volatile $module [splitFp16]
$in ( ua : $uint<16>  )
$out ( sign : $uint<1>   exponent : $uint<5>   mantissa : $uint<10>  )
$is
{
  sign := (ua [] 15 ) $buffering 1
  exponent := ( $slice ua 14 10 )  $buffering 1
  mantissa := ( $slice ua 9 0 )  $buffering 1
}

$volatile $module [classifyFp16]
$in ( ua : $uint<16>  )
$out ( zero : $uint<1>   normal : $uint<1>   nan : $uint<1>   inf : $uint<1>  )
$is
{
  $volatile 	$call splitFp16 (ua ) (sign exponent mantissa ) 
  exp_all_ones := (exponent == ( ~ ($bitcast ($uint<5>) 0  ) )) $buffering 1
  exp_all_zeros := (exponent == 0 ) $buffering 1
  mant_a_zero := (mantissa == 0 ) $buffering 1
  mant_top_bit := (mantissa [] 9 ) $buffering 1
  $volatile 	$call classFpBase (sign exp_all_ones exp_all_zeros mant_a_zero mant_top_bit ) (pos_normal neg_normal pos_denormal neg_denormal qnan snan pos_inf neg_inf pos_zero neg_zero ) 
  $report (fpunit_exec classifyFp16 	 ua ua 	 sign sign 	 mantissa mantissa 	 exponent exponent 	 exp_all_ones exp_all_ones 	 exp_all_ones exp_all_ones 	 exp_all_zeros exp_all_zeros 	 exp_all_zeros exp_all_zeros 	 mant_a_zero mant_a_zero 	 mant_a_zero mant_a_zero 	 mant_top_bit mant_top_bit 	 mant_top_bit mant_top_bit 	 qnan qnan 	 qnan qnan 	 snan snan 	 snan snan )
  zero := ((pos_zero | neg_zero) | (pos_denormal | neg_denormal)) $buffering 1
  normal := (pos_normal | neg_normal) $buffering 1
  nan := (qnan | snan) $buffering 1
  inf := (pos_inf | neg_inf) $buffering 1
}

$volatile $module [classify_and_prepare_32]
$in ( a : $float<8,23>  )
$out ( extended_exponent : $int<13>   extended_mantissa : $uint<32>   special_case : $uint<1>   special_case_result : $float<8,23>  )
$is
{
  $volatile ua := ($bitcast ($uint<32>) a ) $buffering 1
  $report (fpdiv32bitwise classify_and_prepare_32_in_args__ 	 a a 	 ua ua )
  $volatile 	$call classify_32 (a ) (z norm dnorm inf nan ) 
  $report (fpdiv32bitwise classify_and_prepare_32_class 	 z z 	 norm norm 	 dnorm dnorm 	 inf inf 	 nan nan )
  $volatile sa := (ua [] 31 ) $buffering 1
  special_case := ((z | inf) | (nan | sa)) $buffering 1
  uspecial_case_result := ((( $mux z ( $mux sa (1  << 31 )  ZERO_32 )   _b0  )  | ( $mux ((( ~ z ) & sa) & ( ~ nan )) ((sa && ( ~ ZERO_8 )) && (ZERO_1 && ( ~ ZERO_22 )))  _b0  ) ) | (( $mux nan ((sa && ( ~ ZERO_8 )) && (ONE_1 && ZERO_22))  _b0  )  | ( $mux (inf & ( ~ sa )) ((sa && ( ~ ZERO_8 )) && ZERO_23)  _b0  ) )) $buffering 1
  special_case_result := ($bitcast ($float<8,23>) uspecial_case_result ) $buffering 1
  m := ( $slice ua 22 0 )  $buffering 1
  frac := (( $mux dnorm ZERO_1  ONE_1 )  && m) $buffering 1
  $volatile 	$call find_left_24 (frac ) (left_1_index found_1 ) 
  left_shifts_required := (23  - left_1_index) $buffering 1
  $volatile 	$call i24_sll (frac left_shifts_required ) (frac_shifted ) 
  exp := ( $slice ua 30 23 )  $buffering 1
  exp_bias := ( $mux dnorm exp_base_126  exp_base_127 )  $buffering 1
  exp_base := (($bitcast ($int<13>) exp ) - exp_bias) $buffering 1
  ie_13 := (exp_base - ($bitcast ($int<13>) left_shifts_required )) $buffering 1
  extended_exponent := ( $mux (ie_13 [] 0 ) (ie_13 - 1 )  ie_13 )  $buffering 1
  m_base := ( $slice frac_shifted 22 0 )  $buffering 1
  extended_mantissa := ( $mux (ie_13 [] 0 ) ((ONE_1 && m_base) && (ZERO_1 && ZERO_7))  ((ZERO_1 && ONE_1) && (m_base && ZERO_7)) )  $buffering 1
  $report (fpdiv32bitwise classify_and_prepare_32_out_args 	 special_case special_case 	 special_case_result special_case_result 	 extended_exponent extended_exponent 	 extended_mantissa extended_mantissa )
}

$volatile $module [classify_and_prepare_64]
$in ( a : $float<11,52>  )
$out ( extended_exponent : $int<13>   extended_mantissa : $uint<56>   special_case : $uint<1>   special_case_result : $float<11,52>  )
$is
{
  $volatile ua := ($bitcast ($uint<64>) a ) $buffering 1
  $volatile sa := (ua [] 63 ) $buffering 1
  $report (fpdiv64bitwise classify_and_prepare_64_in_args__ 	 a a 	 ua ua )
  $volatile 	$call classify_64 (a ) (z norm dnorm inf nan ) 
  $report (fpdiv364itwise classify_and_prepare_64_class 	 z z 	 norm norm 	 dnorm dnorm 	 inf inf 	 nan nan )
  special_case := ((z | inf) | (nan | sa)) $buffering 1
  uspecial_case_result := ((( $mux z ( $mux sa (1  << 63 )  ZERO_64 )   _b0  )  | ( $mux ((( ~ z ) & sa) & ( ~ nan )) ((sa && ( ~ ZERO_11 )) && (ZERO_1 && ( ~ ZERO_51 )))  _b0  ) ) | (( $mux nan ((sa && ( ~ ZERO_11 )) && (ONE_1 && ZERO_51))  _b0  )  | ( $mux (inf & ( ~ sa )) ((ZERO_1 && ( ~ ZERO_11 )) && ZERO_52)  _b0  ) )) $buffering 1
  special_case_result := ($bitcast ($float<11,52>) uspecial_case_result ) $buffering 1
  m := ( $slice ua 51 0 )  $buffering 1
  frac := (( $mux dnorm ZERO_1  ONE_1 )  && m) $buffering 1
  $volatile 	$call find_left_53 (frac ) (left_1_index found_1 ) 
  left_shifts_required := (52  - left_1_index) $buffering 1
  $volatile 	$call i53_sll (frac left_shifts_required ) (frac_shifted ) 
  exp := ( $slice ua 62 52 )  $buffering 1
  exp_bias := ( $mux dnorm exp_base_1022  exp_base_1023 )  $buffering 1
  exp_base := (($bitcast ($int<13>) exp ) - exp_bias) $buffering 1
  ie_13 := (exp_base - ($bitcast ($int<13>) left_shifts_required )) $buffering 1
  extended_exponent := ( $mux (ie_13 [] 0 ) (ie_13 - 1 )  ie_13 )  $buffering 1
  m_base := ( $slice frac_shifted 51 0 )  $buffering 1
  extended_mantissa := ( $mux (ie_13 [] 0 ) ((ONE_1 && m_base) && ZERO_3)  ((ZERO_1 && ONE_1) && (m_base && ZERO_2)) )  $buffering 1
  $report (fpdiv64bitwise classify_and_prepare_64_out_args 	 special_case special_case 	 special_case_result special_case_result 	 extended_exponent extended_exponent 	 extended_mantissa extended_mantissa )
}

$volatile $module [classify_utility]
$in ( use_single_precision_inputs : $uint<1>   f1_s_class : $uint<10>   f1_d_class : $uint<10>  )
$out ( f1_zero : $uint<1>   f1_normal : $uint<1>   f1_denormal : $uint<1>   f1_nan : $uint<1>   f1_inf : $uint<1>   f1_pos_inf : $uint<1>   f1_neg_inf : $uint<1>  )
$is
{
  $volatile f1_s_pos_normal := ( $slice f1_s_class 9 9 )  $buffering 1
  $volatile f1_s_neg_normal := ( $slice f1_s_class 8 8 )  $buffering 1
  $volatile f1_s_pos_denormal := ( $slice f1_s_class 7 7 )  $buffering 1
  $volatile f1_s_neg_denormal := ( $slice f1_s_class 6 6 )  $buffering 1
  $volatile f1_s_qnan := ( $slice f1_s_class 5 5 )  $buffering 1
  $volatile f1_s_snan := ( $slice f1_s_class 4 4 )  $buffering 1
  $volatile f1_s_pos_inf := ( $slice f1_s_class 3 3 )  $buffering 1
  $volatile f1_s_neg_inf := ( $slice f1_s_class 2 2 )  $buffering 1
  $volatile f1_s_pos_zero := ( $slice f1_s_class 1 1 )  $buffering 1
  $volatile f1_s_neg_zero := ( $slice f1_s_class 0 0 )  $buffering 1
  $volatile f1_d_pos_normal := ( $slice f1_d_class 9 9 )  $buffering 1
  $volatile f1_d_neg_normal := ( $slice f1_d_class 8 8 )  $buffering 1
  $volatile f1_d_pos_denormal := ( $slice f1_d_class 7 7 )  $buffering 1
  $volatile f1_d_neg_denormal := ( $slice f1_d_class 6 6 )  $buffering 1
  $volatile f1_d_qnan := ( $slice f1_d_class 5 5 )  $buffering 1
  $volatile f1_d_snan := ( $slice f1_d_class 4 4 )  $buffering 1
  $volatile f1_d_pos_inf := ( $slice f1_d_class 3 3 )  $buffering 1
  $volatile f1_d_neg_inf := ( $slice f1_d_class 2 2 )  $buffering 1
  $volatile f1_d_pos_zero := ( $slice f1_d_class 1 1 )  $buffering 1
  $volatile f1_d_neg_zero := ( $slice f1_d_class 0 0 )  $buffering 1
  $volatile f1_zero := ( $mux use_single_precision_inputs (f1_s_pos_zero | f1_s_neg_zero)  (f1_d_pos_zero | f1_d_neg_zero) )  $buffering 1
  $volatile f1_normal := ( $mux use_single_precision_inputs (f1_s_pos_normal | f1_s_neg_normal)  (f1_d_pos_normal | f1_d_neg_normal) )  $buffering 1
  $volatile f1_denormal := ( $mux use_single_precision_inputs (f1_s_pos_denormal | f1_s_neg_denormal)  (f1_d_pos_denormal | f1_d_neg_denormal) )  $buffering 1
  $volatile f1_inf := ( $mux use_single_precision_inputs (f1_s_pos_inf | f1_s_neg_inf)  (f1_d_pos_inf | f1_d_neg_inf) )  $buffering 1
  $volatile f1_nan := ( $mux use_single_precision_inputs (f1_s_qnan | f1_s_snan)  (f1_d_snan | f1_d_qnan) )  $buffering 1
  $volatile f1_pos_inf := ( $mux use_single_precision_inputs f1_s_pos_inf  f1_d_pos_inf )  $buffering 1
  $volatile f1_neg_inf := ( $mux use_single_precision_inputs f1_s_neg_inf  f1_d_neg_inf )  $buffering 1
}

$volatile $module [compare4]
$in ( X : $uint<4>   Y : $uint<4>  )
$out ( G : $uint<1>   E : $uint<1>  )
$is
{
  X3 := ( $slice X 3 3 )  $buffering 1
  X2 := ( $slice X 2 2 )  $buffering 1
  X1 := ( $slice X 1 1 )  $buffering 1
  X0 := ( $slice X 0 0 )  $buffering 1
  Y3 := ( $slice Y 3 3 )  $buffering 1
  Y2 := ( $slice Y 2 2 )  $buffering 1
  Y1 := ( $slice Y 1 1 )  $buffering 1
  Y0 := ( $slice Y 0 0 )  $buffering 1
  G3 := (X3 & ( ~ Y3 )) $buffering 1
  E3 := (X3 == Y3) $buffering 1
  G2 := (X2 & ( ~ Y2 )) $buffering 1
  E2 := (X2 == Y2) $buffering 1
  G1 := (X1 & ( ~ Y1 )) $buffering 1
  E1 := (X1 == Y1) $buffering 1
  G0 := (X0 & ( ~ Y0 )) $buffering 1
  E0 := (X0 == Y0) $buffering 1
  G := ((G3 | (E3 & G2)) | (((E3 & E2) & G1) | ((E3 & E2) & (E1 & G0)))) $buffering 1
  E := ((E3 & E2) & (E1 & E0)) $buffering 1
}

$volatile $module [compare8]
$in ( X : $uint<8>   Y : $uint<8>  )
$out ( G : $uint<1>   E : $uint<1>  )
$is
{
  XH := ( $slice X 7 4 )  $buffering 1
  XL := ( $slice X 3 0 )  $buffering 1
  YH := ( $slice Y 7 4 )  $buffering 1
  YL := ( $slice Y 3 0 )  $buffering 1
  $volatile 	$call compare4 (XH YH ) (GH EH ) 
  $volatile 	$call compare4 (XL YL ) (GL EL ) 
  G := (GH | (EH & GL)) $buffering 1
  E := (EH & EL) $buffering 1
}

$volatile $module [compare11]
$in ( X : $uint<11>   Y : $uint<11>  )
$out ( G : $uint<1>   E : $uint<1>  )
$is
{
  XH := ( $slice X 10 8 )  $buffering 1
  XL := ( $slice X 7 0 )  $buffering 1
  YH := ( $slice Y 10 8 )  $buffering 1
  YL := ( $slice Y 7 0 )  $buffering 1
  GH := (XH > YH) $buffering 1
  EH := (XH == YH) $buffering 1
  $volatile 	$call compare8 (XL YL ) (GL EL ) 
  G := (GH | (EH & GL)) $buffering 1
  E := (EH & EL) $buffering 1
}

$volatile $module [compare16]
$in ( X : $uint<16>   Y : $uint<16>  )
$out ( G : $uint<1>   E : $uint<1>  )
$is
{
  XH := ( $slice X 15 8 )  $buffering 1
  XL := ( $slice X 7 0 )  $buffering 1
  YH := ( $slice Y 15 8 )  $buffering 1
  YL := ( $slice Y 7 0 )  $buffering 1
  $volatile 	$call compare8 (XH YH ) (GH EH ) 
  $volatile 	$call compare8 (XL YL ) (GL EL ) 
  G := (GH | (EH & GL)) $buffering 1
  E := (EH & EL) $buffering 1
}

$volatile $module [compare24]
$in ( X : $uint<24>   Y : $uint<24>  )
$out ( G : $uint<1>   E : $uint<1>  )
$is
{
  XH := ( $slice X 23 16 )  $buffering 1
  XL := ( $slice X 15 0 )  $buffering 1
  YH := ( $slice Y 23 16 )  $buffering 1
  YL := ( $slice Y 15 0 )  $buffering 1
  $volatile 	$call compare8 (XH YH ) (GH EH ) 
  $volatile 	$call compare16 (XL YL ) (GL EL ) 
  G := (GH | (EH & GL)) $buffering 1
  E := (EH & EL) $buffering 1
}

$volatile $module [compare32]
$in ( X : $uint<32>   Y : $uint<32>  )
$out ( G : $uint<1>   E : $uint<1>  )
$is
{
  XH := ( $slice X 31 16 )  $buffering 1
  XL := ( $slice X 15 0 )  $buffering 1
  YH := ( $slice Y 31 16 )  $buffering 1
  YL := ( $slice Y 15 0 )  $buffering 1
  $volatile 	$call compare16 (XH YH ) (GH EH ) 
  $volatile 	$call compare16 (XL YL ) (GL EL ) 
  G := (GH | (EH & GL)) $buffering 1
  E := (EH & EL) $buffering 1
}

$volatile $module [compare35]
$in ( X : $uint<35>   Y : $uint<35>  )
$out ( G : $uint<1>   E : $uint<1>  )
$is
{
  XH := ( $slice X 34 32 )  $buffering 1
  XL := ( $slice X 31 0 )  $buffering 1
  YH := ( $slice Y 34 32 )  $buffering 1
  YL := ( $slice Y 31 0 )  $buffering 1
  GH := (XH > YH) $buffering 1
  EH := (XH == YH) $buffering 1
  $volatile 	$call compare32 (XL YL ) (GL EL ) 
  G := (GH | (EH & GL)) $buffering 1
  E := (EH & EL) $buffering 1
}

$volatile $module [compare53]
$in ( X : $uint<53>   Y : $uint<53>  )
$out ( G : $uint<1>   E : $uint<1>  )
$is
{
  XHH := ( $slice X 52 48 )  $buffering 1
  XH := ( $slice X 47 32 )  $buffering 1
  XL := ( $slice X 31 0 )  $buffering 1
  YHH := ( $slice Y 52 48 )  $buffering 1
  YH := ( $slice Y 47 32 )  $buffering 1
  YL := ( $slice Y 31 0 )  $buffering 1
  GHH := (XHH > YHH) $buffering 1
  EHH := (XHH == YHH) $buffering 1
  $volatile 	$call compare16 (XH YH ) (GH EH ) 
  $volatile 	$call compare32 (XL YL ) (GL EL ) 
  G := (GHH | (EHH & (GH | (EH & GL)))) $buffering 1
  E := ((EHH & EH) & EL) $buffering 1
}

$volatile $module [compare64]
$in ( X : $uint<64>   Y : $uint<64>  )
$out ( G : $uint<1>   E : $uint<1>  )
$is
{
  XH := ( $slice X 63 32 )  $buffering 1
  XL := ( $slice X 31 0 )  $buffering 1
  YH := ( $slice Y 63 32 )  $buffering 1
  YL := ( $slice Y 31 0 )  $buffering 1
  $volatile 	$call compare32 (XH YH ) (GH EH ) 
  $volatile 	$call compare32 (XL YL ) (GL EL ) 
  G := (GH | (EH & GL)) $buffering 1
  E := (EH & EL) $buffering 1
}

$volatile $module [comparison_greater_equal_less_26]
$in ( operand1 : $uint<26>   operand2 : $uint<26>  )
$out ( greater_or_equal : $uint<1>   lesser : $uint<1>  )
$is
{
  lesser := (operand1 < operand2) $buffering 1
  greater_or_equal := ( ~ lesser ) $buffering 1
}

$volatile $module [comparison_greater_equal_less_55]
$in ( operand1 : $uint<55>   operand2 : $uint<55>  )
$out ( greater_or_equal : $uint<1>   lesser : $uint<1>  )
$is
{
  operand1_lower := ( $slice operand1 27 0 )  $buffering 1
  operand1_higher := ( $slice operand1 54 28 )  $buffering 1
  operand2_lower := ( $slice operand2 27 0 )  $buffering 1
  operand2_higher := ( $slice operand2 54 28 )  $buffering 1
  higher_equal := (operand1_higher == operand2_higher) $buffering 1
  higher_lesser := (operand1_higher < operand2_higher) $buffering 1
  lower_lesser := (operand1_lower < operand2_lower) $buffering 1
  lesser := (higher_lesser | (higher_equal & lower_lesser)) $buffering 1
  greater_or_equal := ( ~ lesser ) $buffering 1
}

$pipeline $depth 7 $buffering 1 $fullrate $operator $module [delay_32_2]
$in ( X : $uint<32>  )
$out ( Y : $uint<32>  )
$is
{
  Y := X $buffering 2// bits of buffering = 64. 
  $attribute delay 2
}

$pipeline $depth 7 $buffering 1 $fullrate $operator $module [delay_64_3]
$in ( X : $uint<64>  )
$out ( Y : $uint<64>  )
$is
{
  Y := X $buffering 3// bits of buffering = 192. 
  $attribute delay 3
}

$volatile $module [i32_srl]
$in ( X : $uint<32>   S : $uint<5>  )
$out ( Y : $uint<32>  )
$is
{
  X0 := ( $mux (S [] 0 ) (ZERO_1 && ( $slice X 31 1 ) )  X )  $buffering 1
  X1 := ( $mux (S [] 1 ) (ZERO_2 && ( $slice X0 31 2 ) )  X0 )  $buffering 1
  X2 := ( $mux (S [] 2 ) (ZERO_4 && ( $slice X1 31 4 ) )  X1 )  $buffering 1
  X3 := ( $mux (S [] 3 ) (ZERO_8 && ( $slice X2 31 8 ) )  X2 )  $buffering 1
  Y := ( $mux (S [] 4 ) (ZERO_16 && ( $slice X3 31 16 ) )  X3 )  $buffering 1
}

$volatile $module [denormalize_32]
$in ( sign : $uint<1>   biased_exp : $uint<13>   mantissa : $uint<23>  )
$out ( result : $uint<32>  )
$is
{
  $volatile s_biased_exp := ($bitcast ($int<13>) biased_exp ) $buffering 1
  $volatile needs_denormalization := (s_biased_exp < 1 ) $buffering 1
  $volatile denorm_shift_amount := (1  - s_biased_exp) $buffering 1
  $volatile is_denormalizable := (needs_denormalization & (denorm_shift_amount <= 24 )) $buffering 1
  $volatile p := ((ONE_1 && mantissa) && ZERO_8) $buffering 1
  $volatile q := ($bitcast ($uint<5>) denorm_shift_amount ) $buffering 1
  $volatile 	$call i32_srl (p q ) (shifted ) 
  mantissa_denorm_final := ( $slice shifted 30 8 )  $buffering 1
  $volatile result_denormal := ((sign && ZERO_8) && mantissa_denorm_final) $buffering 1
  $volatile result_zero := (sign && ZERO_31) $buffering 1
  $volatile result_normal := ((sign && ( $slice biased_exp 7 0 ) ) && mantissa) $buffering 1
  result := ( $mux needs_denormalization ( $mux is_denormalizable result_denormal  result_zero )   result_normal )  $buffering 1
}

$volatile $module [i64_srl]
$in ( X : $uint<64>   S : $uint<6>  )
$out ( Y : $uint<64>  )
$is
{
  X0 := ( $mux (S [] 0 ) (ZERO_1 && ( $slice X 63 1 ) )  X )  $buffering 1
  X1 := ( $mux (S [] 1 ) (ZERO_2 && ( $slice X0 63 2 ) )  X0 )  $buffering 1
  X2 := ( $mux (S [] 2 ) (ZERO_4 && ( $slice X1 63 4 ) )  X1 )  $buffering 1
  X3 := ( $mux (S [] 3 ) (ZERO_8 && ( $slice X2 63 8 ) )  X2 )  $buffering 1
  X4 := ( $mux (S [] 4 ) (ZERO_16 && ( $slice X3 63 16 ) )  X3 )  $buffering 1
  Y := ( $mux (S [] 5 ) (ZERO_32 && ( $slice X4 63 32 ) )  X4 )  $buffering 1
}

$volatile $module [denormalize_64]
$in ( sign : $uint<1>   biased_exp : $uint<13>   mantissa : $uint<52>  )
$out ( result : $uint<64>  )
$is
{
  $volatile s_biased_exp := ($bitcast ($int<13>) biased_exp ) $buffering 1
  $volatile needs_denormalization := (s_biased_exp < 1 ) $buffering 1
  $volatile denorm_shift_amount := (1  - s_biased_exp) $buffering 1
  $volatile is_denormalizable := (needs_denormalization & (denorm_shift_amount <= 52 )) $buffering 1
  $volatile p := ((ONE_1 && mantissa) && ZERO_11) $buffering 1
  $volatile q := ($bitcast ($uint<6>) denorm_shift_amount ) $buffering 1
  $volatile 	$call i64_srl (p q ) (shifted ) 
  mantissa_denorm_final := ( $slice shifted 62 11 )  $buffering 1
  $volatile result_denormal := ((sign && ZERO_11) && mantissa_denorm_final) $buffering 1
  $volatile result_zero := (sign && ZERO_63) $buffering 1
  $volatile result_normal := ((sign && ( $slice biased_exp 10 0 ) ) && mantissa) $buffering 1
  result := ( $mux needs_denormalization ( $mux is_denormalizable result_denormal  result_zero )   result_normal )  $buffering 1
}

$volatile $module [round_32_extn]
$in ( sticky : $uint<1>   apply_sticky_correction : $uint<1>   unbiased_exp_13 : $uint<13>   mantissa_62 : $uint<62>  )
$out ( sp_biased_exp_13_post_round : $uint<13>   sp_mantissa_23_post_round : $uint<23>  )
$is
{
  $report (fpunit_exec round_32_extn_in_args 	 sticky sticky 	 unbiased_exp_13 unbiased_exp_13 	 mantissa_62 mantissa_62 )
  s_exp_13 := ($bitcast ($uint<13>) unbiased_exp_13 ) $buffering 1
  SP_frac_temp := ((ZERO_1 && ONE_1) && ( $slice mantissa_62 61 39 ) ) $buffering 1
  SP_lsb_frac := (mantissa_62 [] 39 ) $buffering 1
  SP_round_bits := ( $slice mantissa_62 38 0 )  $buffering 1
  SP_round_value_equal := (SP_round_bits == SP_round_mid) $buffering 1
  SP_round_value_greater := (SP_round_bits > SP_round_mid) $buffering 1
  SP_need_to_round := ((SP_round_value_greater | ((SP_round_value_equal & SP_lsb_frac) & ( ~ apply_sticky_correction ))) | ((SP_round_value_equal & sticky) & ( ~ apply_sticky_correction ))) $buffering 1
  SP_round_operator := ( $mux SP_need_to_round ONE_25  ZERO_25 )  $buffering 1
  SP_fraction_rounded := (SP_frac_temp + SP_round_operator) $buffering 1
  SP_increase_exponent := ((( ~ ( $slice SP_frac_temp 22 0 )  ) == _b0 ) & SP_need_to_round) $buffering 1
  $report (fpunit_exec round_32_extn_increase_exponent 	 SP_frac_temp SP_frac_temp 	 SP_increase_exponent SP_increase_exponent 	 SP_fraction_rounded SP_fraction_rounded 	 SP_frac_temp SP_frac_temp )
  sp_mantissa_23_post_round := ( $mux SP_increase_exponent ( $slice SP_fraction_rounded 23 1 )   ( $slice SP_fraction_rounded 22 0 )  )  $buffering 1
  sp_biased_exp_13_post_round := ($bitcast ($uint<13>) (s_exp_13 + ( $mux SP_increase_exponent 128   127  ) ) ) $buffering 1
}

$pipeline $depth 3 $buffering 1 $fullrate $operator $module [denormalize_fp_32]
$in ( extn_result : $uint<81>  )
$out ( f32_result : $uint<32>  )
$is
{
  $volatile EXTENDED_RESULT := extn_result $buffering 1
  $volatile sticky := ( $slice EXTENDED_RESULT 80 80 )  $buffering 1
  $volatile apply_sticky_correction := ( $slice EXTENDED_RESULT 79 79 )  $buffering 1
  $volatile sign := ( $slice EXTENDED_RESULT 78 78 )  $buffering 1
  $volatile nan := ( $slice EXTENDED_RESULT 77 77 )  $buffering 1
  $volatile inf := ( $slice EXTENDED_RESULT 76 76 )  $buffering 1
  $volatile zero := ( $slice EXTENDED_RESULT 75 75 )  $buffering 1
  $volatile u_exp_13 := ( $slice EXTENDED_RESULT 74 62 )  $buffering 1
  $volatile mantissa_62 := ( $slice EXTENDED_RESULT 61 0 )  $buffering 1
  $volatile 	$call round_32_extn (sticky apply_sticky_correction u_exp_13 mantissa_62 ) (sp_exp_13_post_round sp_mantissa_23_post_round ) 
  $volatile 	$call denormalize_32 (sign sp_exp_13_post_round sp_mantissa_23_post_round ) (f32_normalized ) 
  f32_result := f32_normalized $buffering 1// bits of buffering = 32. 
  $attribute delay 1
}

$volatile $module [round_64_extn]
$in ( sticky : $uint<1>   apply_sticky_correction : $uint<1>   unbiased_exp_13 : $uint<13>   mantissa_62 : $uint<62>  )
$out ( dp_biased_exp_13_post_round : $uint<13>   dp_mantissa_52_post_round : $uint<52>  )
$is
{
  s_exp_13 := ($bitcast ($int<13>) unbiased_exp_13 ) $buffering 1
  DP_frac_temp := ((ZERO_1 && ONE_1) && ( $slice mantissa_62 61 10 ) ) $buffering 1
  DP_lsb_frac := (mantissa_62 [] 10 ) $buffering 1
  DP_round_bits := ( $slice mantissa_62 9 0 )  $buffering 1
  DP_round_value_equal := (DP_round_bits == DP_round_mid) $buffering 1
  DP_round_value_greater := (DP_round_bits > DP_round_mid) $buffering 1
  DP_need_to_round := ((DP_round_value_greater | ((DP_round_value_equal & DP_lsb_frac) & ( ~ apply_sticky_correction ))) | ((DP_round_value_equal & sticky) & ( ~ apply_sticky_correction ))) $buffering 1
  DP_round_operator := ( $mux DP_need_to_round ONE_54  ZERO_54 )  $buffering 1
  DP_fraction_rounded := (DP_frac_temp + DP_round_operator) $buffering 1
  DP_increase_exponent := ((( ~ ( $slice DP_frac_temp 51 0 )  ) == _b0 ) & DP_need_to_round) $buffering 1
  dp_biased_exp_13_post_round := ($bitcast ($uint<13>) (s_exp_13 + ( $mux DP_increase_exponent 1024   1023  ) ) ) $buffering 1
  dp_mantissa_52_post_round := ( $mux DP_increase_exponent ( $slice DP_fraction_rounded 52 1 )   ( $slice DP_fraction_rounded 51 0 )  )  $buffering 1
}

$pipeline $depth 3 $buffering 1 $fullrate $operator $module [denormalize_fp_64]
$in ( extn_result : $uint<81>  )
$out ( f64_result : $uint<64>  )
$is
{
  $volatile EXTENDED_RESULT := extn_result $buffering 1
  $volatile sticky := ( $slice EXTENDED_RESULT 80 80 )  $buffering 1
  $volatile apply_sticky_correction := ( $slice EXTENDED_RESULT 79 79 )  $buffering 1
  $volatile sign := ( $slice EXTENDED_RESULT 78 78 )  $buffering 1
  $volatile nan := ( $slice EXTENDED_RESULT 77 77 )  $buffering 1
  $volatile inf := ( $slice EXTENDED_RESULT 76 76 )  $buffering 1
  $volatile zero := ( $slice EXTENDED_RESULT 75 75 )  $buffering 1
  $volatile u_exp_13 := ( $slice EXTENDED_RESULT 74 62 )  $buffering 1
  $volatile mantissa_62 := ( $slice EXTENDED_RESULT 61 0 )  $buffering 1
  $volatile 	$call round_64_extn (sticky apply_sticky_correction u_exp_13 mantissa_62 ) (dp_exp_13_post_round dp_mantissa_52_post_round ) 
  $volatile 	$call denormalize_64 (sign dp_exp_13_post_round dp_mantissa_52_post_round ) (f64_normalized ) 
  f64_result := f64_normalized $buffering 1// bits of buffering = 64. 
  $attribute delay 1
}

$volatile $module [increment_8]
$in ( cA : $uint<8>  )
$out ( B : $uint<8>  )
$is
{
  b7 := ( $slice cA 7 7 )  $buffering 1
  b6 := ( $slice cA 6 6 )  $buffering 1
  b5 := ( $slice cA 5 5 )  $buffering 1
  b4 := ( $slice cA 4 4 )  $buffering 1
  b3 := ( $slice cA 3 3 )  $buffering 1
  b2 := ( $slice cA 2 2 )  $buffering 1
  b1 := ( $slice cA 1 1 )  $buffering 1
  b0 := ( $slice cA 0 0 )  $buffering 1
  c0 := ONE_1 $buffering 1
  c1 := b0 $buffering 1
  c2 := (b1 & b0) $buffering 1
  c3 := ((b2 & b1) & b0) $buffering 1
  c4 := ((b3 & b2) & (b1 & b0)) $buffering 1
  c5 := (((b4 & b3) & b2) & (b1 & b0)) $buffering 1
  c6 := (((b5 & b4) & b3) & ((b2 & b1) & b0)) $buffering 1
  c7 := (((b6 & b5) & (b4 & b3)) & ((b2 & b1) & b0)) $buffering 1
  c := (((c7 && c6) && (c5 && c4)) && ((c3 && c2) && (c1 && c0))) $buffering 1
  B := (cA ^ c) $buffering 1
}

$volatile $module [increment_16]
$in ( A : $uint<16>  )
$out ( B : $uint<16>  )
$is
{
  AH := ( $slice A 15 8 )  $buffering 1
  AL := ( $slice A 7 0 )  $buffering 1
  $volatile 	$call increment_8 (AL ) (BL ) 
  $volatile 	$call increment_8 (AH ) (tBH ) 
  B := (( $mux (( ~ AL ) == 0 ) tBH  AH )  && BL) $buffering 1
}

$pipeline $depth 7 $buffering 1 $fullrate $module [exec_fhtoi16]
$in ( uf1_h : $uint<16>  )
$out ( result : $uint<16>  )
$is
{
  $volatile 	$call classifyFp16 (uf1_h ) (f1_zero f1_normal f1_inf f1_nan ) 
  $volatile 	$call splitFp16 (uf1_h ) (f1_sign f1_exponent f1_mantissa ) 
  $volatile frac_ext := ((($bitcast ($uint<15>) _b0 ) && ($bitcast ($uint<1>) _b1 )) && f1_mantissa) $buffering 1
  $volatile unbiased_exp_h_i9 := (($bitcast ($int<9>) f1_exponent ) - 15) $buffering 1
  $volatile is_zero := (unbiased_exp_h_i9 < 0 ) $buffering 1
  $volatile left_shift_amount := ($bitcast ($uint<26>) unbiased_exp_h_i9 ) $buffering 1
  $volatile overflow := (left_shift_amount > 15 ) $buffering 1
  $volatile ufrac := ( $slice (frac_ext << left_shift_amount) 25 10 )  $buffering 1
  result := ( $mux is_zero 0   ((( $mux (overflow & f1_sign) _h8000   _b0  )  | ( $mux (overflow & ( ~ f1_sign )) _h7FFF   _b0  ) ) | ( $mux ( ~ overflow ) ( $mux f1_sign ( $call increment_16 (( ~ ufrac ) ) )  ufrac )   _b0  ) ) )  $buffering 2// bits of buffering = 32. 
  $attribute delay 2
  $attribute input_buffering 0
  $attribute output_buffering 0
}


$volatile $module [twos_complement_16]
$in ( A : $uint<16>  )
$out ( B : $uint<16>  )
$is
{
  cA := ( ~ A ) $buffering 1
  $volatile 	$call increment_16 (cA ) (B ) 
}

$volatile $module [i16_sll]
$in ( X : $uint<16>   S : $uint<5>  )
$out ( Y : $uint<16>  )
$is
{
  X0 := ( $mux (S [] 0 ) (( $slice X 14 0 )  && ZERO_1)  X )  $buffering 1
  X1 := ( $mux (S [] 1 ) (( $slice X0 13 0 )  && ZERO_2)  X0 )  $buffering 1
  X2 := ( $mux (S [] 2 ) (( $slice X1 11 0 )  && ZERO_4)  X1 )  $buffering 1
  X3 := ( $mux (S [] 3 ) (( $slice X2 7 0 )  && ZERO_8)  X2 )  $buffering 1
  Y := ( $mux (S [] 4 ) 0   X3 )  $buffering 1
}

$pipeline $depth 3 $buffering 1 $fullrate $module [exec_fi16toh]
$in ( X : $uint<16>  )
$out ( Y : $uint<16>  )
$is
{
  $volatile 	$call twos_complement_16 (X ) (Xcompl ) 
  $volatile sign := (X [] 15 ) $buffering 1
  $volatile Xmagn := ( $mux sign Xcompl  X )  $buffering 1
  $volatile 	$call find_left_16 (Xmagn ) (pos1 found1 ) 
  $volatile is_zero := (Xmagn == 0 ) $buffering 1
  $volatile shift_amount := ($bitcast ($uint<5>) (16  - ($bitcast ($uint<5>) pos1 )) ) $buffering 1
  $volatile expon := (($bitcast ($uint<5>) pos1 ) + 15) $buffering 1
  $volatile 	$call i16_sll (Xmagn shift_amount ) (shifted_mantissa_16 ) 
  $volatile mantissa := ( $slice shifted_mantissa_16 15 6 )  $buffering 1
  $volatile result_nz := ((sign && expon) && mantissa) $buffering 1
  Y := ( $mux is_zero 0   result_nz )  $buffering 2// bits of buffering = 32. 
  $attribute input_buffering 0
  $attribute output_buffering 0
}

$volatile $module [exec_fhtos]
$in ( uf1_h : $uint<16>  )
$out ( result : $uint<32>  )
$is
{
  $volatile 	$call splitFp16 (uf1_h ) (uf1_sign uf1_exponent uf1_mantissa ) 
  $volatile 	$call classifyFp16 (uf1_h ) (f1_zero f1_normal f1_nan f1_inf ) 
  $volatile unbiased_exp_h := (($bitcast ($int<9>) uf1_exponent ) - 15) $buffering 1
  $volatile exp_8 := ($bitcast ($uint<8>) (unbiased_exp_h + 127 ) ) $buffering 1
  $volatile man_23 := (uf1_mantissa && ($bitcast ($uint<13>) 0  )) $buffering 1
  $volatile result_norm := ((uf1_sign && exp_8) && man_23) $buffering 1
  $volatile result_qnan := ((ZERO_1 && ($bitcast ($uint<8>) _hFF  )) && (ONE_1 && ZERO_22)) $buffering 1
  $volatile result_zero := (uf1_sign && ZERO_31) $buffering 1
  $volatile result_infinity := ((uf1_sign && ($bitcast ($uint<8>) _hFF  )) && ZERO_23) $buffering 1
  result := ( $mux f1_inf result_infinity  ( $mux f1_zero result_zero  ( $mux f1_normal result_norm  result_qnan )  )  )  $buffering 2
  $attribute delay 2
  $attribute input_buffernig 0
  $attribute output_buffering 0
}

$volatile $module [getHalfInf]
$in ( s : $uint<1>  )
$out ( ret_val : $uint<16>  )
$is
{
  exp := ( ~ ($bitcast ($uint<5>) 0  ) ) $buffering 1
  mant := ($bitcast ($uint<10>) 0  ) $buffering 1
  ret_val := ((s && exp) && mant) $buffering 1
}

$volatile $module [getHalfZero]
$in ( s : $uint<1>  )
$out ( ret_val : $uint<16>  )
$is
{
  ret_val := (s && ($bitcast ($uint<15>) _b0 )) $buffering 1
}

$volatile $module [getHalfNan]
$in ( s : $uint<1>  )
$out ( ret_val : $uint<16>  )
$is
{
  exp := ( ~ ($bitcast ($uint<5>) 0  ) ) $buffering 1
  mant := (ONE_1 && ($bitcast ($uint<9>) 0  )) $buffering 1
  ret_val := ((s && exp) && mant) $buffering 1
}

$volatile $module [exec_fstoh]
$in ( uf1_s : $uint<32>  )
$out ( result : $uint<16>  )
$is
{
  $volatile sign_s := (uf1_s [] 31 ) $buffering 1
  $volatile exp_s := ( $slice uf1_s 30 23 )  $buffering 1
  $volatile mant_s := ( $slice uf1_s 22 0 )  $buffering 1
  $volatile 	$call classify_32 (($bitcast ($float<8,23>) uf1_s ) ) (f1_zero f1_normal f1_denormal f1_inf f1_nan ) 
  $volatile bias := ($bitcast ($int<10>) ( $mux f1_denormal ($bitcast ($int<10>) 126  )  127  )  ) $buffering 1
  $volatile exp_without_bias := (($bitcast ($int<10>) exp_s ) - bias) $buffering 1
  $volatile all_ones_exponent_10 := ( ~ ZERO_10 ) $buffering 1
  $volatile max_h_exponent := ($bitcast ($int<10>) 16 ) $buffering 1
  $volatile min_h_exponent := ($bitcast ($int<10>) -15 ) $buffering 1
  $volatile exp_overflow := (exp_without_bias > max_h_exponent) $buffering 1
  $volatile exp_underflow := (exp_without_bias < min_h_exponent) $buffering 1
  $volatile mantissa_h := ( $slice mant_s 22 13 )  $buffering 1
  $volatile nominal_h_bias := ($bitcast ($int<10>) 15 ) $buffering 1
  $volatile exp_normal := ($bitcast ($uint<5>) (exp_without_bias + nominal_h_bias) ) $buffering 1
  $volatile result_normal := ((sign_s && exp_normal) && mantissa_h) $buffering 1
  $volatile result_abnormal := ( $mux (f1_inf | exp_overflow) ( $call getHalfInf (sign_s ) )  ( $mux ((f1_zero | f1_denormal) | exp_underflow) ( $call getHalfZero (sign_s ) )  ( $call getHalfNan (sign_s ) ) )  )  $buffering 1
  $volatile abnormal_flag := (((f1_inf | f1_zero) | f1_denormal) | (exp_overflow | exp_underflow)) $buffering 1
  result := ( $mux abnormal_flag result_abnormal  result_normal )  $buffering 2
  $attribute delay 2
  $attribute input_buffering 0
  $attribute output_buffering 0
}

$volatile $module [negate_classification]
$in ( C : $uint<10>  )
$out ( NC : $uint<10>  )
$is
{
  pn := ( $slice C 9 9 )  $buffering 1
  nn := ( $slice C 8 8 )  $buffering 1
  pd := ( $slice C 7 7 )  $buffering 1
  nd := ( $slice C 6 6 )  $buffering 1
  qn := ( $slice C 5 5 )  $buffering 1
  sn := ( $slice C 4 4 )  $buffering 1
  pi := ( $slice C 3 3 )  $buffering 1
  ni := ( $slice C 2 2 )  $buffering 1
  pz := ( $slice C 1 1 )  $buffering 1
  nz := ( $slice C 0 0 )  $buffering 1
  cn := (pn | nn) $buffering 1
  cd := (pd | nd) $buffering 1
  ci := (pi | ni) $buffering 1
  cz := (pz | nz) $buffering 1
  NC := (((((cn & ( ~ pn )) && (cn & ( ~ nn ))) && (cd & ( ~ pd ))) && ((cd & ( ~ nd )) && qn)) && (((sn && (ci & ( ~ pi ))) && (ci & ( ~ ni ))) && ((cz & ( ~ pz )) && (cz & ( ~ nz ))))) $buffering 1
}

$volatile $module [expDiffDouble]
$in ( uf1_d : $uint<64>   uf2_d : $uint<64>   f1_denormal : $uint<1>   f2_denormal : $uint<1>  )
$out ( exp_a_greater_than_exp_b_d : $uint<1>   exp_a_equal_exp_b_d : $uint<1>   exp_ab_d : $int<13>  )
$is
{
  ea := ( $slice uf1_d 62 52 )  $buffering 1
  eb := ( $slice uf2_d 62 52 )  $buffering 1
  $volatile 	$call compare11 (ea eb ) (exp_a_greater_than_exp_b_d exp_a_equal_exp_b_d ) 
  eab_n := (ea - eb) $buffering 1
  eba_n := (eb - ea) $buffering 1
  eab := ((( $mux (( ~ f1_denormal ) & ( ~ f2_denormal )) eab_n  _b0  )  | ( $mux (f1_denormal & f2_denormal) ($bitcast ($uint<11>) _b0 )  _b0  ) ) | (( $mux (( ~ f1_denormal ) & f2_denormal) (ea - 1 )  _b0  )  | ( $mux (f1_denormal & ( ~ f2_denormal )) (1  - eb)  _b0  ) )) $buffering 1
  eba := ((( $mux (( ~ f2_denormal ) & ( ~ f1_denormal )) eba_n  _b0  )  | ( $mux (f2_denormal & f1_denormal) ($bitcast ($uint<11>) _b0 )  _b0  ) ) | (( $mux (( ~ f2_denormal ) & f1_denormal) (eb - 1 )  _b0  )  | ( $mux (f2_denormal & ( ~ f1_denormal )) (1  - ea)  _b0  ) )) $buffering 1
  exp_ab_d := ($bitcast ($int<13>) ( $mux exp_a_greater_than_exp_b_d eab  eba )  ) $buffering 1
}

$volatile $module [expDiffSingle]
$in ( uf1_s : $uint<32>   uf2_s : $uint<32>   f1_denormal : $uint<1>   f2_denormal : $uint<1>  )
$out ( exp_a_greater_than_exp_b_s : $uint<1>   exp_a_equal_exp_b_s : $uint<1>   exp_ab_s : $int<13>  )
$is
{
  ea := ( $slice uf1_s 30 23 )  $buffering 1
  eb := ( $slice uf2_s 30 23 )  $buffering 1
  $volatile 	$call compare8 (ea eb ) (exp_a_greater_than_exp_b_s exp_a_equal_exp_b_s ) 
  eab_n := (ea - eb) $buffering 1
  eba_n := (eb - ea) $buffering 1
  eab := ((( $mux (( ~ f1_denormal ) & ( ~ f2_denormal )) eab_n  _b0  )  | ( $mux (f1_denormal & f2_denormal) ($bitcast ($uint<8>) _b0 )  _b0  ) ) | (( $mux (( ~ f1_denormal ) & f2_denormal) (ea - 1 )  _b0  )  | ( $mux (f1_denormal & ( ~ f2_denormal )) (1  - eb)  _b0  ) )) $buffering 1
  eba := ((( $mux (( ~ f2_denormal ) & ( ~ f1_denormal )) eba_n  _b0  )  | ( $mux (f2_denormal & f1_denormal) ($bitcast ($uint<8>) _b0 )  _b0  ) ) | (( $mux (( ~ f2_denormal ) & f1_denormal) (eb - 1 )  _b0  )  | ( $mux (f2_denormal & ( ~ f1_denormal )) (1  - ea)  _b0  ) )) $buffering 1
  exp_ab_s := ($bitcast ($int<13>) ( $mux exp_a_greater_than_exp_b_s eab  eba )  ) $buffering 1
}

$volatile $module [u64_sr_special]
$in ( X : $uint<64>   S : $uint<7>  )
$out ( Y : $uint<64>   sticky : $uint<1>  )
$is
{
  X0 := ( $mux (S [] 0 ) (ZERO_1 && ( $slice X 63 1 ) )  X )  $buffering 1
  t0 := ( $mux (S [] 0 ) (X [] 0 )  _b0  )  $buffering 1
  X1 := ( $mux (S [] 1 ) (ZERO_2 && ( $slice X0 63 2 ) )  X0 )  $buffering 1
  t1 := ( $mux (S [] 1 ) ( ~ (( $slice X0 1 0 )  == 0 ) )  _b0  )  $buffering 1
  X2 := ( $mux (S [] 2 ) (ZERO_4 && ( $slice X1 63 4 ) )  X1 )  $buffering 1
  t2 := ( $mux (S [] 2 ) ( ~ (( $slice X1 3 0 )  == 0 ) )  _b0  )  $buffering 1
  X3 := ( $mux (S [] 3 ) (ZERO_8 && ( $slice X2 63 8 ) )  X2 )  $buffering 1
  t3 := ( $mux (S [] 3 ) ( ~ (( $slice X2 7 0 )  == 0 ) )  _b0  )  $buffering 1
  X4 := ( $mux (S [] 4 ) (ZERO_16 && ( $slice X3 63 16 ) )  X3 )  $buffering 1
  t4 := ( $mux (S [] 4 ) ( ~ (( $slice X3 15 0 )  == 0 ) )  _b0  )  $buffering 1
  X5 := ( $mux (S [] 5 ) (ZERO_32 && ( $slice X4 63 32 ) )  X4 )  $buffering 1
  t5 := ( $mux (S [] 5 ) ( ~ (( $slice X4 31 0 )  == 0 ) )  _b0  )  $buffering 1
  Y := ( $mux (S [] 6 ) _b0   X5 )  $buffering 1
  sticky := (((t0 | t1) | t2) | ((t3 | t4) | t5)) $buffering 1
}

$volatile $module [i64_sll]
$in ( X : $uint<64>   S : $uint<6>  )
$out ( Y : $uint<64>  )
$is
{
  X0 := ( $mux (S [] 0 ) (( $slice X 62 0 )  && ZERO_1)  X )  $buffering 1
  X1 := ( $mux (S [] 1 ) (( $slice X0 61 0 )  && ZERO_2)  X0 )  $buffering 1
  X2 := ( $mux (S [] 2 ) (( $slice X1 59 0 )  && ZERO_4)  X1 )  $buffering 1
  X3 := ( $mux (S [] 3 ) (( $slice X2 55 0 )  && ZERO_8)  X2 )  $buffering 1
  X4 := ( $mux (S [] 4 ) (( $slice X3 47 0 )  && ZERO_16)  X3 )  $buffering 1
  Y := ( $mux (S [] 5 ) (( $slice X4 31 0 )  && ZERO_32)  X4 )  $buffering 1
}

$pipeline $depth 7 $buffering 1 $fullrate $deterministic $operator $module [fpadd64_op]
$in ( use_single_precision_inputs : $uint<1>   double_precision_outputs : $uint<1>   uf1_s : $uint<32>   f1_s_class : $uint<10>   uf2_s : $uint<32>   f2_s_class : $uint<10>   uf1_d_i : $uint<64>   f1_d_class : $uint<10>   uf2_d_i : $uint<64>   f2_d_class : $uint<10>  )
$out ( needs_norm : $uint<1>   extn_result : $uint<81>  )
$is
{
  $volatile 	$call SingleToExtendedFp (uf1_s f1_s_class ) (uf1_s_efp ) 
  $volatile 	$call SingleToExtendedFp (uf2_s f2_s_class ) (uf2_s_efp ) 
  $volatile 	$call DoubleToExtendedFp (uf1_d_i f1_d_class ) (uf1_d_i_efp ) 
  $volatile 	$call DoubleToExtendedFp (uf2_d_i f2_d_class ) (uf2_d_i_efp ) 
  $volatile uf1_d_efp := ( $mux use_single_precision_inputs uf1_s_efp  uf1_d_i_efp )  $buffering 1
  $volatile uf2_d_efp := ( $mux use_single_precision_inputs uf2_s_efp  uf2_d_i_efp )  $buffering 1
  $volatile sign_uf1_d := ( $slice uf1_d_efp 66 66 )  $buffering 1
  $volatile f1_exp13_unbiased := ( $slice uf1_d_efp 65 53 )  $buffering 1
  $volatile f1_top_bit := ( $slice uf1_d_efp 52 52 )  $buffering 1
  $volatile f1_fraction := ( $slice uf1_d_efp 51 0 )  $buffering 1
  $volatile sign_uf2_d := ( $slice uf2_d_efp 66 66 )  $buffering 1
  $volatile f2_exp13_unbiased := ( $slice uf2_d_efp 65 53 )  $buffering 1
  $volatile f2_top_bit := ( $slice uf2_d_efp 52 52 )  $buffering 1
  $volatile f2_fraction := ( $slice uf2_d_efp 51 0 )  $buffering 1
  $volatile 	$call classify_utility (use_single_precision_inputs f1_s_class f1_d_class ) (f1_zero f1_normal f1_denormal f1_nan f1_inf f1_pos_inf f1_neg_inf ) 
  $volatile 	$call classify_utility (use_single_precision_inputs f2_s_class f2_d_class ) (f2_zero f2_normal f2_denormal f2_nan f2_inf f2_pos_inf f2_neg_inf ) 
  $volatile f1_frac := (f1_top_bit && f1_fraction) $buffering 1
  $volatile f2_frac := (f2_top_bit && f2_fraction) $buffering 1
  $report (fpunit_exec fpadd64_op_fractions 	 f1_frac f1_frac 	 f2_frac f2_frac )
  $volatile exp_a := ($bitcast ($int<13>) f1_exp13_unbiased ) $buffering 1
  $volatile exp_b := ($bitcast ($int<13>) f2_exp13_unbiased ) $buffering 1
  $volatile is_trivial_add := (f1_zero ^ f2_zero) $buffering 1
  $volatile 	$call expDiffDouble (uf1_d_i uf2_d_i f1_denormal f2_denormal ) (exp_a_greater_than_exp_b_d exp_a_equal_exp_b_d exp_ab_d ) 
  $volatile 	$call expDiffSingle (uf1_s uf2_s f1_denormal f2_denormal ) (exp_a_greater_than_exp_b_s exp_a_equal_exp_b_s exp_ab_s ) 
  $volatile exp_ab := ( $mux is_trivial_add 0   ( $mux use_single_precision_inputs exp_ab_s  exp_ab_d )  )  $buffering 1
  $volatile exp_a_greater_than_exp_b := (( ~ is_trivial_add ) & ( $mux use_single_precision_inputs exp_a_greater_than_exp_b_s  exp_a_greater_than_exp_b_d ) ) $buffering 1
  $volatile exp_a_equal_exp_b := (is_trivial_add | ( $mux use_single_precision_inputs exp_a_equal_exp_b_s  exp_a_equal_exp_b_d ) ) $buffering 1
  $report (fpunit_exec fpadd64_op_exponents 	 exp_a exp_a 	 exp_b exp_b 	 exp_a_greater_than_exp_b exp_a_greater_than_exp_b 	 exp_a_equal_exp_b exp_a_equal_exp_b 	 exp_ab exp_ab )
  $volatile mantissa_a_pre_shift := ((ZERO_1 && f1_frac) && ZERO_10) $buffering 1
  $volatile mantissa_b_pre_shift := ((ZERO_1 && f2_frac) && ZERO_10) $buffering 1
  $volatile to_be_shifted := ( $mux exp_a_greater_than_exp_b mantissa_b_pre_shift  mantissa_a_pre_shift )  $buffering 1
  $volatile exp_ab_7 := ( $mux (exp_ab > 64 ) ($bitcast ($uint<7>) 64  )  ($bitcast ($uint<7>) exp_ab ) )  $buffering 1
  $volatile 	$call u64_sr_special (to_be_shifted exp_ab_7 ) (shifted_output sticky_temp ) 
  $volatile mantissa_a_pre_shift_d := ((ZERO_1 && f1_frac) && ZERO_10) $buffering 1
  $volatile mantissa_b_pre_shift_d := ((ZERO_1 && f2_frac) && ZERO_10) $buffering 1
  $volatile mantissa_a_post_shift := ( $mux (exp_a_greater_than_exp_b | exp_a_equal_exp_b) mantissa_a_pre_shift_d  shifted_output )  $buffering 1
  $volatile mantissa_b_post_shift := ( $mux is_trivial_add mantissa_b_pre_shift_d  ( $mux exp_a_greater_than_exp_b shifted_output  mantissa_b_pre_shift_d )  )  $buffering 1
  $volatile exponent_post_align := ( $mux is_trivial_add ( $mux f1_zero exp_b  exp_a )   ( $mux exp_a_greater_than_exp_b exp_a  exp_b )  )  $buffering 1
  $report (fpunit_exec fpadd64_op_post_shift 	 mantissa_a_post_shift mantissa_a_post_shift 	 mantissa_b_post_shift mantissa_b_post_shift 	 exponent_post_align exponent_post_align )
  $volatile 	$call compare53 (f1_frac f2_frac ) (G E ) 
  $volatile a_frac_ge_b_frac := ( $mux (is_trivial_add | exp_a_equal_exp_b) (G | E)  exp_a_greater_than_exp_b )  $buffering 1
  $volatile a_frac_gt_b_frac := ( $mux exp_a_equal_exp_b G  exp_a_greater_than_exp_b )  $buffering 1
  $volatile need_to_take_twos_complement_a := (((sign_uf1_d & ( ~ sign_uf2_d )) & ( ~ a_frac_ge_b_frac )) | ((( ~ sign_uf1_d ) & sign_uf2_d) & ( ~ a_frac_ge_b_frac ))) $buffering 1
  $volatile need_to_take_twos_complement_b := (((sign_uf2_d & ( ~ sign_uf1_d )) & a_frac_ge_b_frac) | ((( ~ sign_uf2_d ) & sign_uf1_d) & a_frac_ge_b_frac)) $buffering 1
  $volatile a_was_shifted := ( ~ exp_a_greater_than_exp_b ) $buffering 1
  $volatile a_negative := need_to_take_twos_complement_a $buffering 1
  $volatile b_was_shifted := exp_a_greater_than_exp_b $buffering 1
  $volatile b_negative := need_to_take_twos_complement_b $buffering 1
  $volatile apply_sticky_correction := (sticky_temp & ((a_was_shifted & a_negative) | (b_was_shifted & b_negative))) $buffering 1
  $volatile carry_in := (need_to_take_twos_complement_a | need_to_take_twos_complement_b) $buffering 1
  $volatile mantissa_operand_a := ( $mux need_to_take_twos_complement_a ( ~ mantissa_a_post_shift )  mantissa_a_post_shift )  $buffering 1
  $volatile mantissa_operand_b := ( $mux need_to_take_twos_complement_b ( ~ mantissa_b_post_shift )  mantissa_b_post_shift )  $buffering 1
  $volatile 	$call adder_64_with_carry (mantissa_operand_a mantissa_operand_b carry_in ) (mantissa_added carry_out ) 
  $volatile sign_result := (((sign_uf1_d & sign_uf2_d) | ((sign_uf1_d & ( ~ sign_uf2_d )) & a_frac_gt_b_frac)) | ((( ~ sign_uf1_d ) & sign_uf2_d) & ( ~ a_frac_ge_b_frac ))) $buffering 1
  $report (fpunit_exec fpadd64_op_mantissa_added 	 mantissa_operand_a mantissa_operand_a 	 mantissa_operand_b mantissa_operand_b 	 carry_in carry_in 	 mantissa_added mantissa_added 	 carry_out carry_out 	 sign_result sign_result )
  mantissa_out := mantissa_added $buffering 1// bits of buffering = 64. 
  sign_from_addition := sign_result $buffering 1// bits of buffering = 1.  Orphaned statement with target sign_from_addition ?? 
  $volatile need_to_shift := (( ~ carry_in ) & (mantissa_out [] 63 )) $buffering 1
  $volatile mantissa_out_shifted := ( $slice mantissa_out 63 1 )  $buffering 1
  $volatile mantissa_64_bits := ( $mux need_to_shift (ZERO_1 && mantissa_out_shifted)  (ZERO_1 && ( $slice mantissa_out 62 0 ) ) )  $buffering 1
  $report (fpunit_exec fpadd64_op_final_mantissa_64 	 mantissa_64_bits mantissa_64_bits )
  $volatile 	$call find_leftmost_64 (mantissa_64_bits ) (position_of_one one_found ) 
  $volatile left_shift_amount := ($bitcast ($uint<6>) (62  - position_of_one) ) $buffering 1
  $volatile add_result_zero := ( ~ one_found ) $buffering 1
  $volatile 	$call i64_sll (mantissa_64_bits left_shift_amount ) (final_mantissa_aligned ) 
  $volatile final_mantissa_62_aligned := ( $slice final_mantissa_aligned 61 0 )  $buffering 1
  $volatile exponent_correction := (( $mux need_to_shift exp_base_1  exp_base_0 )  - ( $mux one_found ($bitcast ($int<13>) left_shift_amount )  _b0  ) ) $buffering 1
  $volatile final_exponent_without_bias := (exponent_post_align + exponent_correction) $buffering 1
  $report (fpunit_exec fpadd64_op_final_exponent_without_bias 	 exponent_post_align exponent_post_align 	 exponent_correction exponent_correction 	 final_exponent_without_bias final_exponent_without_bias )
  $volatile DP_exp_overflow := (final_exponent_without_bias > 1023 ) $buffering 1
  $volatile DP_exp_underflow := (final_exponent_without_bias < -1022 ) $buffering 1
  $volatile SP_exp_overflow := (final_exponent_without_bias > 127 ) $buffering 1
  $volatile SP_exp_underflow := (final_exponent_without_bias < -126 ) $buffering 1
  $volatile underflow_SP := (SP_exp_underflow & ( ~ add_result_zero )) $buffering 1
  $volatile underflow_DP := (DP_exp_underflow & ( ~ add_result_zero )) $buffering 1
  $volatile overflow_SP := (SP_exp_overflow & ( ~ add_result_zero )) $buffering 1
  $volatile overflow_DP := (DP_exp_overflow & ( ~ add_result_zero )) $buffering 1
  $volatile overflow := ( $mux double_precision_outputs overflow_DP  overflow_SP )  $buffering 1
  $volatile condition_nan := ((f1_nan | f2_nan) | ((f1_pos_inf & f2_neg_inf) | (f1_neg_inf & f2_pos_inf))) $buffering 1
  $volatile condition_inf := ((((f1_pos_inf & f2_pos_inf) | (f1_neg_inf & f2_neg_inf)) | ((f1_pos_inf | f1_neg_inf) & (f2_normal | f2_denormal))) | (((f2_pos_inf | f2_neg_inf) & (f1_normal | f1_denormal)) | overflow)) $buffering 1
  $volatile condition_zero := ((f1_zero & f2_zero) | add_result_zero) $buffering 1
  $volatile underflow := (( ~ condition_zero ) & ( $mux double_precision_outputs underflow_DP  underflow_SP ) ) $buffering 1
  $report (fpunit_exec fpadd64_op_final_exceptions 	 DP_exp_overflow DP_exp_overflow 	 DP_exp_underflow DP_exp_underflow 	 SP_exp_overflow SP_exp_overflow 	 SP_exp_underflow SP_exp_underflow 	 underflow_SP underflow_SP 	 underflow_DP underflow_DP 	 overflow_SP overflow_SP 	 overflow_DP overflow_DP 	 condition_nan condition_nan 	 condition_inf condition_inf 	 condition_zero condition_zero )
  $volatile SP_nothing_to_be_done_condition_normal := (((( ~ overflow ) & ( ~ underflow )) & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  $volatile SP_normalization_required := (((overflow | underflow) & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  $volatile DP_nothing_to_be_done_condition_normal := (((( ~ overflow ) & ( ~ underflow )) & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  $volatile DP_normalization_required := (((overflow | underflow) & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  $volatile normalization_required := ( $mux double_precision_outputs DP_normalization_required  SP_normalization_required )  $buffering 1
  $volatile nothing_to_be_done_condition_normal := ( $mux double_precision_outputs DP_nothing_to_be_done_condition_normal  SP_nothing_to_be_done_condition_normal )  $buffering 1
  $volatile exponent_to_be_passed := (((( $mux condition_nan ALL_ONE_13  _b0  )  | ( $mux condition_inf ALL_ONE_13  _b0  ) ) | ( $mux condition_zero ($bitcast ($int<13>) ZERO_13 )  _b0  ) ) | (( $mux nothing_to_be_done_condition_normal final_exponent_without_bias  _b0  )  | ( $mux normalization_required final_exponent_without_bias  _b0  ) )) $buffering 1
  $volatile mantissa_to_be_passed := ((( $mux condition_nan (ONE_1 && ZERO_61)  _b0  )  | ( $mux (condition_inf | condition_zero) ZERO_62  _b0  ) ) | ( $mux (nothing_to_be_done_condition_normal | normalization_required) final_mantissa_62_aligned  _b0  ) ) $buffering 1
  $volatile condition_to_pass_sticky_bit := ((((a_was_shifted & a_negative) & b_negative) | ((a_was_shifted & ( ~ a_negative )) & ( ~ b_negative ))) | (((b_was_shifted & a_negative) & b_negative) | ((b_was_shifted & ( ~ a_negative )) & ( ~ b_negative )))) $buffering 1
  $volatile sticky := (((sticky_temp & condition_to_pass_sticky_bit) & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  needs_norm := ((normalization_required & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 2// bits of buffering = 2. 
  extn_result := (((sticky && apply_sticky_correction) && (sign_result && condition_nan)) && ((condition_inf && condition_zero) && (($bitcast ($uint<13>) exponent_to_be_passed ) && mantissa_to_be_passed))) $buffering 2// bits of buffering = 162. 
  $report (fpunit_exec fpadd64_op_final_results 	 exponent_to_be_passed exponent_to_be_passed 	 mantissa_to_be_passed mantissa_to_be_passed )
}

$volatile $module [u35_sr_special]
$in ( X : $uint<35>   S : $uint<6>  )
$out ( Y : $uint<35>   sticky : $uint<1>  )
$is
{
  X0 := ( $mux (S [] 0 ) (ZERO_1 && ( $slice X 34 1 ) )  X )  $buffering 1
  t0 := ( $mux (S [] 0 ) (X [] 0 )  _b0  )  $buffering 1
  X1 := ( $mux (S [] 1 ) (ZERO_2 && ( $slice X0 34 2 ) )  X0 )  $buffering 1
  t1 := ( $mux (S [] 1 ) ( ~ (( $slice X0 1 0 )  == 0 ) )  _b0  )  $buffering 1
  X2 := ( $mux (S [] 2 ) (ZERO_4 && ( $slice X1 34 4 ) )  X1 )  $buffering 1
  t2 := ( $mux (S [] 2 ) ( ~ (( $slice X1 3 0 )  == 0 ) )  _b0  )  $buffering 1
  X3 := ( $mux (S [] 3 ) (ZERO_8 && ( $slice X2 34 8 ) )  X2 )  $buffering 1
  t3 := ( $mux (S [] 3 ) ( ~ (( $slice X2 7 0 )  == 0 ) )  _b0  )  $buffering 1
  X4 := ( $mux (S [] 4 ) (ZERO_16 && ( $slice X3 34 16 ) )  X3 )  $buffering 1
  t4 := ( $mux (S [] 4 ) ( ~ (( $slice X3 15 0 )  == 0 ) )  _b0  )  $buffering 1
  Y := ( $mux (S [] 5 ) (ZERO_32 && ( $slice X4 34 32 ) )  X4 )  $buffering 1
  t5 := ( $mux (S [] 5 ) ( ~ (( $slice X4 31 0 )  == 0 ) )  _b0  )  $buffering 1
  sticky := (((t0 | t1) | t2) | ((t3 | t4) | t5)) $buffering 1
}

$volatile $module [find_leftmost_35]
$in ( fp_35 : $uint<35>  )
$out ( position : $uint<6>   found : $uint<1>  )
$is
{
  $volatile fp_3_upper := ( $slice fp_35 34 32 )  $buffering 1
  fp_34 := ( $slice fp_3_upper 2 2 )  $buffering 1
  fp_33 := ( $slice fp_3_upper 1 1 )  $buffering 1
  fp_32 := ( $slice fp_3_upper 0 0 )  $buffering 1
  found_upper := (fp_3_upper != 0 ) $buffering 1
  fp_upper_index := ( $mux fp_34 ($bitcast ($uint<6>) _b100010  )  ( $mux fp_33 ($bitcast ($uint<6>) _b100001  )  ($bitcast ($uint<6>) _b100000  ) )  )  $buffering 1
  $volatile fp_32_lower := ( $slice fp_35 31 0 )  $buffering 1
  $volatile 	$call find_left_32 (fp_32_lower ) (fp_32_lower_index found_lower ) 
  $volatile position := ( $mux found_upper fp_upper_index  ( $mux found_lower (ZERO_1 && fp_32_lower_index)  ZERO_6 )  )  $buffering 1
  $volatile found := (found_upper | found_lower) $buffering 1
}

$volatile $module [i35_sll]
$in ( X : $uint<35>   S : $uint<6>  )
$out ( Y : $uint<35>  )
$is
{
  X0 := ( $mux (S [] 0 ) (( $slice X 33 0 )  && ZERO_1)  X )  $buffering 1
  X1 := ( $mux (S [] 1 ) (( $slice X0 32 0 )  && ZERO_2)  X0 )  $buffering 1
  X2 := ( $mux (S [] 2 ) (( $slice X1 30 0 )  && ZERO_4)  X1 )  $buffering 1
  X3 := ( $mux (S [] 3 ) (( $slice X2 26 0 )  && ZERO_8)  X2 )  $buffering 1
  X4 := ( $mux (S [] 4 ) (( $slice X3 18 0 )  && ZERO_16)  X3 )  $buffering 1
  Y := ( $mux (S [] 5 ) (( $slice X4 2 0 )  && ZERO_32)  X4 )  $buffering 1
}

$pipeline $depth 7 $buffering 1 $fullrate $deterministic $operator $module [fpadd32_op]
$in ( uf1_s : $uint<32>   f1_s_class : $uint<10>   uf2_s : $uint<32>   f2_s_class : $uint<10>  )
$out ( needs_norm : $uint<1>   extn_result : $uint<81>  )
$is
{
  $volatile 	$call SingleToExtendedFp (uf1_s f1_s_class ) (uf1_s_efp ) 
  $volatile 	$call SingleToExtendedFp (uf2_s f2_s_class ) (uf2_s_efp ) 
  $volatile sign_uf1_d := ( $slice uf1_s_efp 66 66 )  $buffering 1
  $volatile f1_exp13_unbiased := ( $slice uf1_s_efp 65 53 )  $buffering 1
  $volatile f1_top_bit := ( $slice uf1_s_efp 52 52 )  $buffering 1
  $volatile f1_fraction := ( $slice uf1_s_efp 51 29 )  $buffering 1
  $volatile f1_unused := ( $slice uf1_s_efp 28 0 )  $buffering 1
  $volatile sign_uf2_d := ( $slice uf2_s_efp 66 66 )  $buffering 1
  $volatile f2_exp13_unbiased := ( $slice uf2_s_efp 65 53 )  $buffering 1
  $volatile f2_top_bit := ( $slice uf2_s_efp 52 52 )  $buffering 1
  $volatile f2_fraction := ( $slice uf2_s_efp 51 29 )  $buffering 1
  $volatile f2_unused := ( $slice uf2_s_efp 28 0 )  $buffering 1
  $volatile 	$call classify_utility (ONE_1 f1_s_class _b0  ) (f1_zero f1_normal f1_denormal f1_nan f1_inf f1_pos_inf f1_neg_inf ) 
  $volatile 	$call classify_utility (ONE_1 f2_s_class _b0  ) (f2_zero f2_normal f2_denormal f2_nan f2_inf f2_pos_inf f2_neg_inf ) 
  $volatile f1_frac := (f1_top_bit && f1_fraction) $buffering 1
  $volatile f2_frac := (f2_top_bit && f2_fraction) $buffering 1
  $report (fpunit_exec fpadd32_op_fractions 	 f1_frac f1_frac 	 f2_frac f2_frac )
  $volatile exp_a := ($bitcast ($int<13>) f1_exp13_unbiased ) $buffering 1
  $volatile exp_b := ($bitcast ($int<13>) f2_exp13_unbiased ) $buffering 1
  $volatile 	$call expDiffSingle (uf1_s uf2_s f1_denormal f2_denormal ) (exp_a_greater_than_exp_b exp_a_equal_exp_b exp_ab ) 
  $report (fpunit_exec fpadd32_op_exponents 	 exp_a exp_a 	 exp_b exp_b 	 exp_a_greater_than_exp_b exp_a_greater_than_exp_b 	 exp_a_equal_exp_b exp_a_equal_exp_b )
  $volatile is_trivial_add := (f1_zero ^ f2_zero) $buffering 1
  $volatile mantissa_a_pre_shift_35 := ((ZERO_1 && f1_frac) && ZERO_10) $buffering 1
  $volatile mantissa_b_pre_shift_35 := ((ZERO_1 && f2_frac) && ZERO_10) $buffering 1
  $volatile to_be_shifted_35 := ( $mux is_trivial_add ( $mux f1_zero mantissa_b_pre_shift_35  mantissa_a_pre_shift_35 )   ( $mux exp_a_greater_than_exp_b mantissa_b_pre_shift_35  mantissa_a_pre_shift_35 )  )  $buffering 1
  $volatile exp_ab_6 := ( $mux is_trivial_add 0   ( $mux (exp_ab > 35 ) ($bitcast ($uint<6>) 35  )  ($bitcast ($uint<6>) exp_ab ) )  )  $buffering 1
  $volatile 	$call u35_sr_special (to_be_shifted_35 exp_ab_6 ) (shifted_output_temp_35 sticky_temp ) 
  $volatile shifted_output_35 := ( $mux ( ~ exp_a_equal_exp_b ) shifted_output_temp_35  ($bitcast ($uint<35>) _b0  ) )  $buffering 1
  $volatile mantissa_a_post_shift_35 := ( $mux ((exp_a_greater_than_exp_b | exp_a_equal_exp_b) | is_trivial_add) mantissa_a_pre_shift_35  shifted_output_35 )  $buffering 1
  $volatile mantissa_b_post_shift_35 := ( $mux is_trivial_add mantissa_b_pre_shift_35  ( $mux exp_a_greater_than_exp_b shifted_output_35  mantissa_b_pre_shift_35 )  )  $buffering 1
  $volatile exponent_post_align := ( $mux is_trivial_add ( $mux f1_zero exp_b  exp_a )   ( $mux exp_a_greater_than_exp_b exp_a  exp_b )  )  $buffering 1
  $report (fpunit_exec fpadd32_op_post_shift 	 mantissa_a_post_shift_35 mantissa_a_post_shift_35 	 mantissa_b_post_shift_35 mantissa_b_post_shift_35 	 exponent_post_align exponent_post_align )
  $volatile 	$call compare24 (f1_frac f2_frac ) (G E ) 
  $volatile a_frac_ge_b_frac := ( $mux (is_trivial_add | exp_a_equal_exp_b) (G | E)  exp_a_greater_than_exp_b )  $buffering 1
  $volatile need_to_take_twos_complement_a := (((sign_uf1_d & ( ~ sign_uf2_d )) & ( ~ a_frac_ge_b_frac )) | ((( ~ sign_uf1_d ) & sign_uf2_d) & ( ~ a_frac_ge_b_frac ))) $buffering 1
  $volatile need_to_take_twos_complement_b := (((sign_uf2_d & ( ~ sign_uf1_d )) & a_frac_ge_b_frac) | ((( ~ sign_uf2_d ) & sign_uf1_d) & a_frac_ge_b_frac)) $buffering 1
  $volatile carry_in := (need_to_take_twos_complement_a | need_to_take_twos_complement_b) $buffering 1
  $volatile mantissa_operand_a_35 := ( $mux need_to_take_twos_complement_a ( ~ mantissa_a_post_shift_35 )  mantissa_a_post_shift_35 )  $buffering 1
  $volatile mantissa_operand_b_35 := ( $mux need_to_take_twos_complement_b ( ~ mantissa_b_post_shift_35 )  mantissa_b_post_shift_35 )  $buffering 1
  $volatile 	$call adder_35_with_carry (mantissa_operand_a_35 mantissa_operand_b_35 carry_in ) (mantissa_added_35 carry_out ) 
  $volatile sign_result := (((sign_uf1_d & sign_uf2_d) | ((sign_uf1_d & ( ~ sign_uf2_d )) & a_frac_ge_b_frac)) | ((( ~ sign_uf1_d ) & sign_uf2_d) & ( ~ a_frac_ge_b_frac ))) $buffering 1
  $report (fpunit_exec fpadd32_op_mantissa_added 	 mantissa_operand_a_35 mantissa_operand_a_35 	 mantissa_operand_b_35 mantissa_operand_b_35 	 carry_in carry_in 	 mantissa_added_35 mantissa_added_35 	 carry_out carry_out 	 sign_result sign_result )
  $volatile sign_from_addition := sign_result $buffering 1
  mantissa_out_35 := mantissa_added_35 $buffering 1// bits of buffering = 35. 
  $volatile need_to_shift := (( ~ carry_in ) & (mantissa_out_35 [] 34 )) $buffering 1
  $volatile mantissa_out_shifted_34 := ( $slice mantissa_out_35 34 1 )  $buffering 1
  $volatile mantissa_35_bits := ( $mux need_to_shift (ZERO_1 && mantissa_out_shifted_34)  (ZERO_1 && ( $slice mantissa_out_35 33 0 ) ) )  $buffering 1
  $report (fpunit_exec fpadd32_op_final_mantissa_35 	 mantissa_35_bits mantissa_35_bits )
  $volatile 	$call find_leftmost_35 (mantissa_35_bits ) (position_of_one one_found ) 
  $volatile left_shift_amount := ($bitcast ($uint<6>) (33  - position_of_one) ) $buffering 1
  $volatile add_result_zero := ( ~ one_found ) $buffering 1
  $volatile 	$call i35_sll (mantissa_35_bits left_shift_amount ) (final_mantissa_aligned_35 ) 
  $volatile final_mantissa_33_aligned := ( $slice final_mantissa_aligned_35 32 0 )  $buffering 1
  $volatile final_mantissa_62_aligned := (final_mantissa_33_aligned && ($bitcast ($uint<29>) _b0  )) $buffering 1
  $volatile exponent_correction := (( $mux need_to_shift exp_base_1  exp_base_0 )  - ( $mux one_found ($bitcast ($int<13>) left_shift_amount )  _b0  ) ) $buffering 1
  $volatile final_exponent_without_bias := (exponent_post_align + exponent_correction) $buffering 1
  $report (fpunit_exec fpadd32_op_final_exponent_without_bias 	 exponent_post_align exponent_post_align 	 exponent_correction exponent_correction 	 final_exponent_without_bias final_exponent_without_bias )
  $volatile SP_exp_overflow := (final_exponent_without_bias > 127 ) $buffering 1
  $volatile SP_exp_underflow := (final_exponent_without_bias < -126 ) $buffering 1
  $volatile underflow_SP := (SP_exp_underflow & ( ~ add_result_zero )) $buffering 1
  $volatile overflow_SP := (SP_exp_overflow & ( ~ add_result_zero )) $buffering 1
  $volatile overflow := overflow_SP $buffering 1
  $volatile condition_nan := ((f1_nan | f2_nan) | ((f1_pos_inf & f2_neg_inf) | (f1_neg_inf & f2_pos_inf))) $buffering 1
  $volatile condition_inf := ((((f1_pos_inf & f2_pos_inf) | (f1_neg_inf & f2_neg_inf)) | (f1_neg_inf & (f2_normal | f2_denormal))) | ((((f1_pos_inf | f1_neg_inf) & (f2_normal | f2_denormal)) | ((f2_pos_inf | f2_neg_inf) & (f1_normal | f1_denormal))) | overflow)) $buffering 1
  $volatile condition_zero := ((f1_zero & f2_zero) | add_result_zero) $buffering 1
  $volatile underflow := (( ~ condition_zero ) & underflow_SP) $buffering 1
  $report (fpunit_exec fpadd32_op_final_exceptions 	 SP_exp_overflow SP_exp_overflow 	 SP_exp_underflow SP_exp_underflow 	 underflow_SP underflow_SP 	 overflow_SP overflow_SP 	 condition_nan condition_nan 	 condition_inf condition_inf 	 condition_zero condition_zero )
  $volatile SP_nothing_to_be_done_condition_normal := (((( ~ overflow ) & ( ~ underflow )) & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  $volatile SP_normalization_required := (((overflow | underflow) & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  $volatile normalization_required := SP_normalization_required $buffering 1
  $volatile nothing_to_be_done_condition_normal := SP_nothing_to_be_done_condition_normal $buffering 1
  $volatile exponent_to_be_passed := (((( $mux condition_nan ALL_ONE_13  _b0  )  | ( $mux condition_inf ALL_ONE_13  _b0  ) ) | ( $mux condition_zero ($bitcast ($int<13>) ZERO_13 )  _b0  ) ) | (( $mux nothing_to_be_done_condition_normal final_exponent_without_bias  _b0  )  | ( $mux normalization_required final_exponent_without_bias  _b0  ) )) $buffering 1
  $volatile mantissa_to_be_passed := ((( $mux condition_nan (ONE_1 && ZERO_61)  _b0  )  | ( $mux (condition_inf | condition_zero) ZERO_62  _b0  ) ) | ( $mux (nothing_to_be_done_condition_normal | normalization_required) final_mantissa_62_aligned  _b0  ) ) $buffering 1
  $volatile a_was_shifted := ( ~ exp_a_greater_than_exp_b ) $buffering 1
  $volatile a_negative := need_to_take_twos_complement_a $buffering 1
  $volatile b_was_shifted := exp_a_greater_than_exp_b $buffering 1
  $volatile b_negative := need_to_take_twos_complement_b $buffering 1
  $volatile condition_to_pass_sticky_bit := ((((a_was_shifted & a_negative) & b_negative) | ((a_was_shifted & ( ~ a_negative )) & ( ~ b_negative ))) | (((b_was_shifted & a_negative) & b_negative) | ((b_was_shifted & ( ~ a_negative )) & ( ~ b_negative )))) $buffering 1
  $volatile sticky := (((sticky_temp & condition_to_pass_sticky_bit) & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  $volatile apply_sticky_correction := (sticky_temp & ((a_was_shifted & a_negative) | (b_was_shifted & b_negative))) $buffering 1
  needs_norm := ((normalization_required & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 2// bits of buffering = 2. 
  extn_result := (((sticky && apply_sticky_correction) && (sign_result && condition_nan)) && ((condition_inf && condition_zero) && (($bitcast ($uint<13>) exponent_to_be_passed ) && mantissa_to_be_passed))) $buffering 2// bits of buffering = 162. 
  $report (fpunit_exec fpadd32_op_final_results 	 exponent_to_be_passed exponent_to_be_passed 	 mantissa_to_be_passed mantissa_to_be_passed )
}

$pipeline $depth 3 $buffering 1 $fullrate $deterministic $operator $module [mul24]
$in ( L : $uint<24>   R : $uint<24>  )
$out ( RESULT : $uint<48>  )
$is
{
  $volatile A1 := ( $slice L 23 12 )  $buffering 1
  $volatile A0 := ( $slice L 11 0 )  $buffering 1
  $volatile B1 := ( $slice R 23 12 )  $buffering 1
  $volatile B0 := ( $slice R 11 0 )  $buffering 1
  $volatile a0b0 := (($bitcast ($uint<24>) A0 ) * ($bitcast ($uint<24>) B0 )) $buffering 1
  $volatile a0b1 := (($bitcast ($uint<24>) A0 ) * ($bitcast ($uint<24>) B1 )) $buffering 1
  $volatile a1b0 := (($bitcast ($uint<24>) A1 ) * ($bitcast ($uint<24>) B0 )) $buffering 1
  $volatile a1b1 := (($bitcast ($uint<24>) A1 ) * ($bitcast ($uint<24>) B1 )) $buffering 1
  $volatile a0b0_l := ( $slice a0b0 11 0 )  $buffering 1
  $volatile a0b0_h := ( $slice a0b0 23 12 )  $buffering 1
  $volatile a0b1_l := ( $slice a0b1 11 0 )  $buffering 1
  $volatile a0b1_h := ( $slice a0b1 23 12 )  $buffering 1
  $volatile a1b0_l := ( $slice a1b0 11 0 )  $buffering 1
  $volatile a1b0_h := ( $slice a1b0 23 12 )  $buffering 1
  $volatile a1b1_l := ( $slice a1b1 11 0 )  $buffering 1
  $volatile a1b1_h := ( $slice a1b1 23 12 )  $buffering 1
  $volatile P0 := a0b0_l $buffering 1
  $volatile eP1 := (($bitcast ($uint<14>) a0b0_h ) + (($bitcast ($uint<14>) a0b1_l ) + ($bitcast ($uint<14>) a1b0_l ))) $buffering 1
  $volatile P1 := ( $slice eP1 11 0 )  $buffering 1
  $volatile cP1 := ($bitcast ($uint<14>) ( $slice eP1 13 12 )  ) $buffering 1
  $volatile eP2 := ((($bitcast ($uint<14>) a1b0_h ) + ($bitcast ($uint<14>) a0b1_h )) + (($bitcast ($uint<14>) a1b1_l ) + cP1)) $buffering 1
  $volatile P2 := ( $slice eP2 11 0 )  $buffering 1
  $volatile cP2 := ($bitcast ($uint<12>) ( $slice eP2 13 12 )  ) $buffering 1
  $volatile P3 := (($bitcast ($uint<12>) a1b1_h ) + cP2) $buffering 1
  RESULT := ((P3 && P2) && (P1 && P0)) $buffering 1// bits of buffering = 48. 
  $attribute delay 1
}

$pipeline $depth 7 $buffering 1 $fullrate $deterministic $operator $module [fpmul32_op]
$in ( uf1_s : $uint<32>   f1_s_class : $uint<10>   uf2_s : $uint<32>   f2_s_class : $uint<10>  )
$out ( needs_norm : $uint<1>   extn_result : $uint<81>  )
$is
{
  $volatile 	$call classify_utility (ONE_1 f1_s_class 0  ) (f1_zero f1_normal f1_denormal f1_nan f1_inf f1_pos_inf f1_neg_inf ) 
  $volatile 	$call classify_utility (ONE_1 f2_s_class 0  ) (f2_zero f2_normal f2_denormal f2_nan f2_inf f2_pos_inf f2_neg_inf ) 
  $volatile 	$call SingleToExtendedFp (uf1_s f1_s_class ) (uf1_s_efp ) 
  $volatile 	$call SingleToExtendedFp (uf2_s f2_s_class ) (uf2_s_efp ) 
  $volatile sign_uf1_s := ( $slice uf1_s_efp 66 66 )  $buffering 1
  $volatile f1_exp13_unbiased := ( $slice uf1_s_efp 65 53 )  $buffering 1
  $volatile f1_top_bit := ( $slice uf1_s_efp 52 52 )  $buffering 1
  $volatile f1_fraction := ( $slice uf1_s_efp 51 29 )  $buffering 1
  $volatile f1_unused := ( $slice uf1_s_efp 28 0 )  $buffering 1
  $volatile sign_uf2_s := ( $slice uf2_s_efp 66 66 )  $buffering 1
  $volatile f2_exp13_unbiased := ( $slice uf2_s_efp 65 53 )  $buffering 1
  $volatile f2_top_bit := ( $slice uf2_s_efp 52 52 )  $buffering 1
  $volatile f2_fraction := ( $slice uf2_s_efp 51 29 )  $buffering 1
  $volatile f2_unused := ( $slice uf2_s_efp 28 0 )  $buffering 1
  $volatile sign_result := (sign_uf1_s ^ sign_uf2_s) $buffering 1
  $volatile f1_frac_v := (f1_top_bit && f1_fraction) $buffering 1
  $volatile f2_frac_v := (f2_top_bit && f2_fraction) $buffering 1
  $volatile exp_a := ($bitcast ($int<13>) f1_exp13_unbiased ) $buffering 1
  $volatile exp_b := ($bitcast ($int<13>) f2_exp13_unbiased ) $buffering 1
  $volatile 	$call find_left_24 (f1_frac_v ) (f1_top_bit_pos f1_top_bit_found ) 
  $volatile 	$call find_left_24 (f2_frac_v ) (f2_top_bit_pos f2_top_bit_found ) 
  $volatile f1_left_shift_correction := ($bitcast ($int<13>) (23  - f1_top_bit_pos) ) $buffering 1
  $volatile exp_a_corrected := (exp_a - f1_left_shift_correction) $buffering 1
  $volatile f2_left_shift_correction := ($bitcast ($int<13>) (23  - f2_top_bit_pos) ) $buffering 1
  $volatile exp_b_corrected := (exp_b - f2_left_shift_correction) $buffering 1
  $volatile mul_result_left_shift_amount := (f1_left_shift_correction + f2_left_shift_correction) $buffering 1
  $volatile f1_frac := f1_frac_v $buffering 1
  $volatile f2_frac := f2_frac_v $buffering 1
  $volatile exp_ab := (exp_a_corrected + exp_b_corrected) $buffering 1
  $call mul24 (f1_frac f2_frac ) (frac_result_48bits ) 
  $volatile frac_result_35 := ( $slice frac_result_48bits 47 13 )  $buffering 1
  $volatile value_of_bits_thrown_away_greater_than_zero := ( ~ (( $slice frac_result_35 6 0 )  == 0 ) ) $buffering 1
  $volatile implied_shift_amount := ( $mux (mul_result_left_shift_amount > 35 ) 35   ($bitcast ($uint<6>) mul_result_left_shift_amount ) )  $buffering 1
  $volatile 	$call i35_sll (frac_result_35 implied_shift_amount ) (frac_result_35_with_implied_shift ) 
  $volatile shift_by_one := (frac_result_35_with_implied_shift [] 34 ) $buffering 1
  $volatile thrown_away_bit := ( $mux shift_by_one (frac_result_35_with_implied_shift [] 0 )  _b0  )  $buffering 1
  $volatile mantissa_33_bits := ( $mux shift_by_one ( $slice frac_result_35_with_implied_shift 33 1 )   ( $slice frac_result_35_with_implied_shift 32 0 )  )  $buffering 1
  $volatile mantissa_62_bits := (mantissa_33_bits && ($bitcast ($uint<29>) _b0  )) $buffering 1
  $volatile sticky_raw := (thrown_away_bit | value_of_bits_thrown_away_greater_than_zero) $buffering 1
  $volatile exponent_correction := ( $mux shift_by_one exp_base_1  exp_base_0 )  $buffering 1
  $volatile exponent_without_bias := (exp_ab + exponent_correction) $buffering 1
  $volatile SP_overflow := (exponent_without_bias > 127 ) $buffering 1
  $volatile SP_underflow := (exponent_without_bias < -126 ) $buffering 1
  $volatile overflow := SP_overflow $buffering 1
  $volatile condition_zero := (f1_zero | f2_zero) $buffering 1
  $volatile condition_nan := ((f1_nan | f2_nan) | ((f1_zero & f2_inf) | (f1_inf & f2_zero))) $buffering 1
  $volatile condition_inf := (((f1_inf & ((f2_inf | f2_normal) | f2_denormal)) | (f2_inf & ((f1_inf | f1_normal) | f1_denormal))) | overflow) $buffering 1
  $volatile underflow := (( ~ condition_zero ) & SP_underflow) $buffering 1
  $volatile sticky := ((sticky_raw & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  $volatile SP_nothing_to_be_done_condition_normal := (((( ~ overflow ) & ( ~ underflow )) & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  $volatile SP_normalization_required := (((overflow | underflow) & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  $volatile normalization_required := SP_normalization_required $buffering 1
  $volatile nothing_to_be_done_condition_normal := SP_nothing_to_be_done_condition_normal $buffering 1
  condition_nan_d := condition_nan $buffering 1// bits of buffering = 1. 
  condition_zero_d := condition_zero $buffering 1// bits of buffering = 1. 
  $volatile exponent_to_be_passed := ((( $mux (condition_nan_d | condition_inf) ALL_ONE_13  _b0  )  | ( $mux condition_zero_d ($bitcast ($int<13>) ZERO_13 )  _b0  ) ) | ( $mux (normalization_required | nothing_to_be_done_condition_normal) exponent_without_bias  _b0  ) ) $buffering 1
  $volatile mantissa_to_be_passed := ((( $mux condition_nan_d (ONE_1 && ZERO_61)  _b0  )  | ( $mux condition_inf ZERO_62  _b0  ) ) | (( $mux condition_zero_d ZERO_62  _b0  )  | ( $mux (normalization_required | nothing_to_be_done_condition_normal) mantissa_62_bits  _b0  ) )) $buffering 1
  needs_norm := ((normalization_required & ( ~ condition_zero_d )) & (( ~ condition_inf ) & ( ~ condition_nan_d ))) $buffering 2// bits of buffering = 2. 
  extn_result := (((sticky && nothing_to_be_done_condition_normal) && (sign_result && condition_nan_d)) && ((condition_inf && condition_zero_d) && (($bitcast ($uint<13>) exponent_to_be_passed ) && mantissa_to_be_passed))) $buffering 2// bits of buffering = 162. 
}

$volatile $module [round_fp_32]
$in ( EXTENDED_RESULT : $uint<81>  )
$out ( RESULT_32 : $uint<32>  )
$is
{
  $volatile sticky := ( $slice EXTENDED_RESULT 80 80 )  $buffering 1
  $volatile apply_sticky_correction := ( $slice EXTENDED_RESULT 79 79 )  $buffering 1
  $volatile sign := ( $slice EXTENDED_RESULT 78 78 )  $buffering 1
  $volatile nan := ( $slice EXTENDED_RESULT 77 77 )  $buffering 1
  $volatile inf := ( $slice EXTENDED_RESULT 76 76 )  $buffering 1
  $volatile zero := ( $slice EXTENDED_RESULT 75 75 )  $buffering 1
  $volatile unbiased_exp_13 := ( $slice EXTENDED_RESULT 74 62 )  $buffering 1
  $volatile mantissa_62 := ( $slice EXTENDED_RESULT 61 0 )  $buffering 1
  $report (fpunit_exec round_fp_in_args 	 sticky sticky 	 apply_sticky_correction apply_sticky_correction 	 sign sign 	 nan nan 	 inf inf 	 zero zero 	 unbiased_exp_13 unbiased_exp_13 	 mantissa_62 mantissa_62 )
  $volatile 	$call round_32_extn (sticky apply_sticky_correction unbiased_exp_13 mantissa_62 ) (sp_biased_exp_13_post_round sp_mantissa_23_post_round ) 
  RESULT_32 := ( $mux ((nan | inf) | zero) ((sign && ( $slice unbiased_exp_13 7 0 ) ) && ( $slice mantissa_62 61 39 ) )  ((sign && ( $slice sp_biased_exp_13_post_round 7 0 ) ) && sp_mantissa_23_post_round) )  $buffering 1
}

$pipeline $depth 3 $buffering 2 $fullrate $deterministic $operator $module [mul53]
$in ( L : $uint<53>   R : $uint<53>  )
$out ( RESULT : $uint<106>  )
$is
{
  $volatile A1 := (ZERO_1 && ( $slice L 52 27 ) ) $buffering 1
  $volatile A0 := ( $slice L 26 0 )  $buffering 1
  $volatile B1 := (ZERO_1 && ( $slice R 52 27 ) ) $buffering 1
  $volatile B0 := ( $slice R 26 0 )  $buffering 1
  a0b0 := (($bitcast ($uint<54>) A0 ) * ($bitcast ($uint<54>) B0 )) $buffering 1// bits of buffering = 54. 
  a0b1 := (($bitcast ($uint<54>) A0 ) * ($bitcast ($uint<54>) B1 )) $buffering 1// bits of buffering = 54. 
  a1b0 := (($bitcast ($uint<54>) A1 ) * ($bitcast ($uint<54>) B0 )) $buffering 1// bits of buffering = 54. 
  a1b1 := (($bitcast ($uint<54>) A1 ) * ($bitcast ($uint<54>) B1 )) $buffering 1// bits of buffering = 54. 
  $volatile a0b0_l := ( $slice a0b0 26 0 )  $buffering 1
  $volatile a0b0_h := ( $slice a0b0 53 27 )  $buffering 1
  $volatile a0b1_l := ( $slice a0b1 26 0 )  $buffering 1
  $volatile a0b1_h := ( $slice a0b1 53 27 )  $buffering 1
  $volatile a1b0_l := ( $slice a1b0 26 0 )  $buffering 1
  $volatile a1b0_h := ( $slice a1b0 53 27 )  $buffering 1
  $volatile a1b1_l := ( $slice a1b1 26 0 )  $buffering 1
  $volatile a1b1_h := ( $slice a1b1 53 27 )  $buffering 1
  $volatile P0 := a0b0_l $buffering 1
  $volatile eP1 := (($bitcast ($uint<29>) a0b0_h ) + (($bitcast ($uint<29>) a0b1_l ) + ($bitcast ($uint<29>) a1b0_l ))) $buffering 1
  $volatile P1 := ( $slice eP1 26 0 )  $buffering 1
  $volatile cP1 := ($bitcast ($uint<29>) ( $slice eP1 28 27 )  ) $buffering 1
  $volatile eP2 := ((($bitcast ($uint<29>) a1b0_h ) + ($bitcast ($uint<29>) a0b1_h )) + (($bitcast ($uint<29>) a1b1_l ) + cP1)) $buffering 1
  $volatile P2 := ( $slice eP2 26 0 )  $buffering 1
  $volatile cP2 := ($bitcast ($uint<25>) ( $slice eP2 28 27 )  ) $buffering 1
  $volatile P3 := (($bitcast ($uint<25>) a1b1_h ) + cP2) $buffering 1
  RESULT := ((P3 && P2) && (P1 && P0)) $buffering 1// bits of buffering = 106. 
  $attribute delay 1
}

$pipeline $depth 7 $buffering 1 $fullrate $deterministic $operator $module [fpmul64_op]
$in ( use_single_precision_inputs : $uint<1>   double_precision_outputs : $uint<1>   uf1_s : $uint<32>   f1_s_class : $uint<10>   uf2_s : $uint<32>   f2_s_class : $uint<10>   uf1_d_i : $uint<64>   f1_d_class : $uint<10>   uf2_d_i : $uint<64>   f2_d_class : $uint<10>  )
$out ( needs_norm : $uint<1>   extn_result : $uint<81>  )
$is
{
  $volatile 	$call classify_utility (use_single_precision_inputs f1_s_class f1_d_class ) (f1_zero f1_normal f1_denormal f1_nan f1_inf f1_pos_inf f1_neg_inf ) 
  $volatile 	$call classify_utility (use_single_precision_inputs f2_s_class f2_d_class ) (f2_zero f2_normal f2_denormal f2_nan f2_inf f2_pos_inf f2_neg_inf ) 
  $volatile 	$call SingleToExtendedFp (uf1_s f1_s_class ) (uf1_s_efp ) 
  $volatile 	$call SingleToExtendedFp (uf2_s f2_s_class ) (uf2_s_efp ) 
  $volatile 	$call DoubleToExtendedFp (uf1_d_i f1_d_class ) (uf1_d_i_efp ) 
  $volatile 	$call DoubleToExtendedFp (uf2_d_i f2_d_class ) (uf2_d_i_efp ) 
  $volatile uf1_d_efp := ( $mux use_single_precision_inputs uf1_s_efp  uf1_d_i_efp )  $buffering 1
  $volatile uf2_d_efp := ( $mux use_single_precision_inputs uf2_s_efp  uf2_d_i_efp )  $buffering 1
  $volatile sign_uf1_d := ( $slice uf1_d_efp 66 66 )  $buffering 1
  $volatile f1_exp13_unbiased := ( $slice uf1_d_efp 65 53 )  $buffering 1
  $volatile f1_top_bit := ( $slice uf1_d_efp 52 52 )  $buffering 1
  $volatile f1_fraction := ( $slice uf1_d_efp 51 0 )  $buffering 1
  $volatile sign_uf2_d := ( $slice uf2_d_efp 66 66 )  $buffering 1
  $volatile f2_exp13_unbiased := ( $slice uf2_d_efp 65 53 )  $buffering 1
  $volatile f2_top_bit := ( $slice uf2_d_efp 52 52 )  $buffering 1
  $volatile f2_fraction := ( $slice uf2_d_efp 51 0 )  $buffering 1
  $volatile sign_result := (sign_uf1_d ^ sign_uf2_d) $buffering 1
  $volatile f1_frac_v := (f1_top_bit && f1_fraction) $buffering 1
  $volatile f2_frac_v := (f2_top_bit && f2_fraction) $buffering 1
  $volatile exp_a := ($bitcast ($int<13>) f1_exp13_unbiased ) $buffering 1
  $volatile exp_b := ($bitcast ($int<13>) f2_exp13_unbiased ) $buffering 1
  $volatile 	$call find_left_53 (f1_frac_v ) (f1_top_bit_pos f1_top_bit_found ) 
  $volatile 	$call find_left_53 (f2_frac_v ) (f2_top_bit_pos f2_top_bit_found ) 
  $volatile f1_left_shift_correction := ($bitcast ($int<13>) (52  - f1_top_bit_pos) ) $buffering 1
  $volatile exp_a_corrected := (exp_a - f1_left_shift_correction) $buffering 1
  $volatile f2_left_shift_correction := ($bitcast ($int<13>) (52  - f2_top_bit_pos) ) $buffering 1
  $volatile exp_b_corrected := (exp_b - f2_left_shift_correction) $buffering 1
  $volatile mul_result_left_shift_amount := (f1_left_shift_correction + f2_left_shift_correction) $buffering 1
  $volatile exp_ab := (exp_a_corrected + exp_b_corrected) $buffering 1
  $call mul53 (f1_frac_v f2_frac_v ) (frac_result_106bits ) 
  $volatile frac_result_64 := ( $slice frac_result_106bits 105 42 )  $buffering 1
  $volatile value_of_bits_thrown_away_greater_than_zero := ( ~ (( $slice frac_result_106bits 41 0 )  == 0 ) ) $buffering 1
  $volatile implied_shift_amount := ($bitcast ($uint<6>) mul_result_left_shift_amount ) $buffering 1
  $volatile 	$call i64_sll (frac_result_64 implied_shift_amount ) (frac_result_64_with_implied_shift_raw ) 
  $volatile frac_result_64_with_implied_shift := ( $mux (mul_result_left_shift_amount > 63 ) 0   frac_result_64_with_implied_shift_raw )  $buffering 1
  $volatile shift_by_one := (frac_result_64_with_implied_shift [] 63 ) $buffering 1
  $volatile thrown_away_bit := ( $mux shift_by_one (frac_result_64_with_implied_shift [] 0 )  _b0  )  $buffering 1
  $volatile mantissa_62_bits := ( $mux shift_by_one ( $slice frac_result_64_with_implied_shift 62 1 )   ( $slice frac_result_64_with_implied_shift 61 0 )  )  $buffering 1
  $volatile sticky_raw := (thrown_away_bit | value_of_bits_thrown_away_greater_than_zero) $buffering 1
  $volatile exponent_correction := ( $mux shift_by_one exp_base_1  exp_base_0 )  $buffering 1
  $volatile exponent_without_bias := (exp_ab + exponent_correction) $buffering 1
  $volatile DP_overflow := (exponent_without_bias > 1023 ) $buffering 1
  $volatile DP_underflow := (exponent_without_bias < -1022 ) $buffering 1
  $volatile SP_overflow := (exponent_without_bias > 127 ) $buffering 1
  $volatile SP_underflow := (exponent_without_bias < -126 ) $buffering 1
  $volatile overflow := ( $mux double_precision_outputs DP_overflow  SP_overflow )  $buffering 1
  $volatile condition_zero := (f1_zero | f2_zero) $buffering 1
  $volatile condition_nan := ((f1_nan | f2_nan) | ((f1_zero & f2_inf) | (f1_inf & f2_zero))) $buffering 1
  $volatile condition_inf := (((f1_inf & ((f2_inf | f2_normal) | f2_denormal)) | (f2_inf & ((f1_inf | f1_normal) | f1_denormal))) | overflow) $buffering 1
  $volatile underflow := (( ~ condition_zero ) & ( $mux double_precision_outputs DP_underflow  SP_underflow ) ) $buffering 1
  $volatile sticky := ((sticky_raw & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  $volatile SP_nothing_to_be_done_condition_normal := (((( ~ overflow ) & ( ~ underflow )) & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  $volatile SP_normalization_required := (((overflow | underflow) & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  $volatile DP_nothing_to_be_done_condition_normal := (((( ~ overflow ) & ( ~ underflow )) & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  $volatile DP_normalization_required := (((overflow | underflow) & ( ~ condition_zero )) & (( ~ condition_inf ) & ( ~ condition_nan ))) $buffering 1
  $volatile normalization_required := ( $mux double_precision_outputs DP_normalization_required  SP_normalization_required )  $buffering 1
  $volatile nothing_to_be_done_condition_normal := ( $mux double_precision_outputs DP_nothing_to_be_done_condition_normal  SP_nothing_to_be_done_condition_normal )  $buffering 1
  // begin inlined macro delay_1_1
  condition_nan_d := condition_nan $buffering 1// bits of buffering = 1. 
  // end inlined macro delay_1_1
  // begin inlined macro delay_1_1
  condition_zero_d := condition_zero $buffering 1// bits of buffering = 1. 
  // end inlined macro delay_1_1
  $volatile exponent_to_be_passed := ((( $mux (condition_nan_d | condition_inf) ALL_ONE_13  _b0  )  | ( $mux condition_zero_d ($bitcast ($int<13>) ZERO_13 )  _b0  ) ) | ( $mux (normalization_required | nothing_to_be_done_condition_normal) exponent_without_bias  _b0  ) ) $buffering 1
  $volatile mantissa_to_be_passed := ((( $mux condition_nan_d (ONE_1 && ZERO_61)  _b0  )  | ( $mux condition_inf ZERO_62  _b0  ) ) | (( $mux condition_zero_d ZERO_62  _b0  )  | ( $mux (normalization_required | nothing_to_be_done_condition_normal) mantissa_62_bits  _b0  ) )) $buffering 1
  needs_norm := ((normalization_required & ( ~ condition_zero_d )) & (( ~ condition_inf ) & ( ~ condition_nan_d ))) $buffering 2// bits of buffering = 2. 
  extn_result := (((sticky && ZERO_1) && (sign_result && condition_nan_d)) && ((condition_inf && condition_zero_d) && (($bitcast ($uint<13>) exponent_to_be_passed ) && mantissa_to_be_passed))) $buffering 2// bits of buffering = 162. 
}

$volatile $module [increment_32]
$in ( A : $uint<32>  )
$out ( B : $uint<32>  )
$is
{
  AH := ( $slice A 31 16 )  $buffering 1
  AL := ( $slice A 15 0 )  $buffering 1
  $volatile 	$call increment_16 (AL ) (BL ) 
  $volatile 	$call increment_16 (AH ) (tBH ) 
  B := (( $mux (( ~ AL ) == 0 ) tBH  AH )  && BL) $buffering 1
}

$volatile $module [i32_sll]
$in ( X : $uint<32>   S : $uint<6>  )
$out ( Y : $uint<32>  )
$is
{
  X0 := ( $mux (S [] 0 ) (( $slice X 30 0 )  && ZERO_1)  X )  $buffering 1
  X1 := ( $mux (S [] 1 ) (( $slice X0 29 0 )  && ZERO_2)  X0 )  $buffering 1
  X2 := ( $mux (S [] 2 ) (( $slice X1 27 0 )  && ZERO_4)  X1 )  $buffering 1
  X3 := ( $mux (S [] 3 ) (( $slice X2 23 0 )  && ZERO_8)  X2 )  $buffering 1
  X4 := ( $mux (S [] 4 ) (( $slice X3 15 0 )  && ZERO_16)  X3 )  $buffering 1
  Y := ( $mux (S [] 5 ) 0   X4 )  $buffering 1
}

$volatile $module [fitod64]
$in ( X : $uint<32>  )
$out ( Y : $float<11,52>  )
$is
{
  $volatile S := (X [] 31 ) $buffering 1
  $volatile notX := ( ~ X ) $buffering 1
  $volatile 	$call increment_32 (notX ) (twosComplX ) 
  $volatile iX := ( $mux S twosComplX  X )  $buffering 1
  $volatile 	$call find_left_32 (iX ) (idx_raw found ) 
  $volatile exponent := ((ZERO_1 && ( ~ ZERO_10 )) + ($bitcast ($uint<11>) idx_raw )) $buffering 1
  $volatile ls_amount := (32  - ($bitcast ($uint<6>) idx_raw )) $buffering 1
  $volatile 	$call i32_sll (iX ls_amount ) (ix_shifted ) 
  $volatile mantissa := (ix_shifted && ZERO_20) $buffering 1
  $volatile uY := ( $mux found ((S && exponent) && mantissa)  ZERO_64 )  $buffering 1
  $volatile Y := ($bitcast ($float<11,52>) uY ) $buffering 2
}

$volatile $module [round_fp_64]
$in ( EXTENDED_RESULT : $uint<81>  )
$out ( RESULT_64 : $uint<64>  )
$is
{
  $volatile sticky := ( $slice EXTENDED_RESULT 80 80 )  $buffering 1
  $volatile apply_sticky_correction := ( $slice EXTENDED_RESULT 79 79 )  $buffering 1
  $volatile sign := ( $slice EXTENDED_RESULT 78 78 )  $buffering 1
  $volatile nan := ( $slice EXTENDED_RESULT 77 77 )  $buffering 1
  $volatile inf := ( $slice EXTENDED_RESULT 76 76 )  $buffering 1
  $volatile zero := ( $slice EXTENDED_RESULT 75 75 )  $buffering 1
  $volatile unbiased_exp_13 := ( $slice EXTENDED_RESULT 74 62 )  $buffering 1
  $volatile mantissa_62 := ( $slice EXTENDED_RESULT 61 0 )  $buffering 1
  $report (fpunit_exec round_fp_in_args 	 sticky sticky 	 apply_sticky_correction apply_sticky_correction 	 sign sign 	 nan nan 	 inf inf 	 zero zero 	 unbiased_exp_13 unbiased_exp_13 	 mantissa_62 mantissa_62 )
  $volatile 	$call round_64_extn (sticky apply_sticky_correction unbiased_exp_13 mantissa_62 ) (dp_biased_exp_13_post_round dp_mantissa_52_post_round ) 
  RESULT_64 := ( $mux ((nan | inf) | zero) ((sign && ( $slice unbiased_exp_13 10 0 ) ) && ( $slice mantissa_62 61 10 ) )  ((sign && ( $slice dp_biased_exp_13_post_round 10 0 ) ) && dp_mantissa_52_post_round) )  $buffering 1
}

$volatile $module [negateVal]
$in ( a : $uint<16>  )
$out ( ret_val : $uint<16>  )
$is
{
  ret_val := ( $mux (a != 0 ) (( ~ (a [] 15 ) ) && ( $slice a 14 0 ) )  a )  $buffering 1
}

$pipeline $depth 5 $buffering 1 $fullrate $deterministic $operator $module [faddsub16]
$in ( f1 : $uint<16>   f2 : $uint<16>   sub : $uint<1>  )
$out ( result : $uint<16>  )
$is
{
  $constant  ctr : $uint<1>:= 0  
  $volatile 	$call negateVal (f2 ) (f2c ) 
  $volatile f2_actual := ( $mux sub f2c  f2 )  $buffering 1
  $volatile 	$call classifyFp16 (f1 ) (f1_zero f1_normal f1_nan f1_inf ) 
  $volatile 	$call classifyFp16 (f2_actual ) (f2_zero f2_normal f2_nan f2_inf ) 
  $volatile 	$call splitFp16 (f1 ) (sign_f1 f1_exp f1_fraction ) 
  $volatile 	$call splitFp16 (f2_actual ) (sign_f2 f2_exp f2_fraction ) 
  $volatile f1_frac := (ONE_1 && f1_fraction) $buffering 1
  $volatile f2_frac := (ONE_1 && f2_fraction) $buffering 1
  $volatile exp_a := (($bitcast ($int<7>) f1_exp ) - 15) $buffering 1
  $volatile exp_b := (($bitcast ($int<7>) f2_exp ) - 15) $buffering 1
  $volatile exp_a_minus_b := (exp_a - exp_b) $buffering 1
  $volatile exp_b_minus_a := (exp_b - exp_a) $buffering 1
  $volatile exp_a_greater_than_b := (exp_a > exp_b) $buffering 1
  $volatile exp_a_equal_exp_b := (exp_a == exp_b) $buffering 1
  $volatile exp_ab := ( $mux exp_a_greater_than_b exp_a_minus_b  exp_b_minus_a )  $buffering 1
  $volatile mantissa_a_pre_shift := ((ZERO_1 && f1_frac) && ($bitcast ($uint<1>) 0  )) $buffering 1
  $volatile mantissa_b_pre_shift := ((ZERO_1 && f2_frac) && ($bitcast ($uint<1>) 0  )) $buffering 1
  $volatile to_be_shifted := ( $mux exp_a_greater_than_b mantissa_b_pre_shift  mantissa_a_pre_shift )  $buffering 1
  $volatile shifted_output := (to_be_shifted >> ($bitcast ($uint<13>) exp_ab )) $buffering 1
  $volatile mantissa_a_post_shift := ( $mux (exp_a_greater_than_b | exp_a_equal_exp_b) mantissa_a_pre_shift  shifted_output )  $buffering 1
  $volatile mantissa_b_post_shift := ( $mux exp_a_greater_than_b shifted_output  mantissa_b_pre_shift )  $buffering 1
  $volatile exponent_post_align := ( $mux exp_a_greater_than_b exp_a  exp_b )  $buffering 1
  $volatile a_frac_ge_b_frac := (mantissa_a_post_shift >= mantissa_b_post_shift) $buffering 1
  $volatile need_to_take_twos_complement_a := (((sign_f1 & ( ~ sign_f2 )) & ( ~ a_frac_ge_b_frac )) | ((( ~ sign_f1 ) & sign_f2) & ( ~ a_frac_ge_b_frac ))) $buffering 1
  $volatile need_to_take_twos_complement_b := (((sign_f2 & ( ~ sign_f1 )) & a_frac_ge_b_frac) | ((( ~ sign_f2 ) & sign_f1) & a_frac_ge_b_frac)) $buffering 1
  $volatile carry_in := (need_to_take_twos_complement_a | need_to_take_twos_complement_b) $buffering 1
  $volatile mantissa_operand_a_ext := (( $mux need_to_take_twos_complement_a ( ~ mantissa_a_post_shift )  mantissa_a_post_shift )  && carry_in) $buffering 1
  $volatile mantissa_operand_b_ext := (( $mux need_to_take_twos_complement_b ( ~ mantissa_b_post_shift )  mantissa_b_post_shift )  && carry_in) $buffering 1
  $volatile mantissa_added_ext := (mantissa_operand_a_ext + mantissa_operand_b_ext) $buffering 1
  $volatile need_to_shift := (((sign_f1 & sign_f2) | (( ~ sign_f1 ) & ( ~ sign_f2 ))) & (mantissa_added_ext [] 13 )) $buffering 1
  $volatile mantissa_out_shifted := ( $slice mantissa_added_ext 13 3 )  $buffering 1
  $volatile mantissa_out_unshifted := ( $slice mantissa_added_ext 12 2 )  $buffering 1
  $volatile sign_result := (((sign_f1 & sign_f2) | ((sign_f1 & ( ~ sign_f2 )) & a_frac_ge_b_frac)) | ((( ~ sign_f1 ) & sign_f2) & ( ~ a_frac_ge_b_frac ))) $buffering 1
  $volatile mantissa_non_normalized := ( $mux need_to_shift (ZERO_1 && mantissa_out_shifted)  (ZERO_1 && mantissa_out_unshifted) )  $buffering 1
  $volatile 	$call find_left_16 (($bitcast ($uint<16>) mantissa_non_normalized ) ) (position_of_one one_found ) 
  $volatile left_shift_amount := (10 - ($bitcast ($uint<5>) position_of_one )) $buffering 1
  $volatile 	$call i16_sll (($bitcast ($uint<16>) mantissa_non_normalized ) left_shift_amount ) (final_mantissa_aligned_16 ) 
  $volatile final_mantissa := ( $slice final_mantissa_aligned_16 9 0 )  $buffering 1
  $volatile left_shift_amount_E := ($bitcast ($int<7>) left_shift_amount ) $buffering 1
  $volatile final_exponent_without_bias := ((exponent_post_align - ( $mux one_found left_shift_amount_E  _b0  ) ) + ( $mux need_to_shift 1   0  ) ) $buffering 1
  $volatile final_exponent := ($bitcast ($uint<5>) (final_exponent_without_bias + 15) ) $buffering 1
  $volatile 	$call check_fh_exponent_overflow (final_exponent_without_bias ) (overflow underflow ) 
  $volatile non_zero_result := ((sign_result && final_exponent) && final_mantissa) $buffering 1
  $volatile result_normal := ( $mux one_found non_zero_result  _b0  )  $buffering 1
  $volatile result_abnormal := (((( $mux (f1_nan | f2_nan) ( $call getHalfNan (ZERO_1 ) )  _b0  )  | ( $mux (underflow | (f1_zero & f2_zero)) ( $call getHalfZero (ZERO_1 ) )  _b0  ) ) | ( $mux (((f1_inf & f2_inf) & (sign_f1 == sign_f2)) | overflow) ( $call getHalfInf (sign_f1 ) )  _b0  ) ) | ((( $mux ((f1_inf & f2_inf) & (sign_f1 != sign_f2)) ( $call getHalfNan (ZERO_1 ) )  _b0  )  | ( $mux (f1_inf & f2_zero) ( $call getHalfInf (sign_f1 ) )  _b0  ) ) | ( $mux (f1_zero & f2_inf) ( $call getHalfInf ((sign_f1 ^ sub) ) )  _b0  ) )) $buffering 1
  $volatile abnormal_flag := (((f1_inf | f2_inf) | (f1_nan | f2_nan)) | ((overflow | underflow) | (f1_zero & f2_zero))) $buffering 1
  result := ( $mux abnormal_flag result_abnormal  result_normal )  $buffering 2// bits of buffering = 32. 
}

$pipeline $depth 5 $buffering 1 $fullrate $deterministic $operator $module [fmul16]
$in ( f1 : $uint<16>   f2 : $uint<16>  )
$out ( result : $uint<16>  )
$is
{
  $volatile 	$call classifyFp16 (f1 ) (f1_zero f1_normal f1_nan f1_inf ) 
  $volatile 	$call classifyFp16 (f2 ) (f2_zero f2_normal f2_nan f2_inf ) 
  $volatile sign_f1 := ( $slice f1 15 15 )  $buffering 1
  $volatile f1_exp_biased := ( $slice f1 14 10 )  $buffering 1
  $volatile f1_fraction := ( $slice f1 9 0 )  $buffering 1
  $volatile exp_a := (($bitcast ($int<7>) f1_exp_biased ) - 15) $buffering 1
  $volatile sign_f2 := ( $slice f2 15 15 )  $buffering 1
  $volatile f2_exp_biased := ( $slice f2 14 10 )  $buffering 1
  $volatile f2_fraction := ( $slice f2 9 0 )  $buffering 1
  $volatile exp_b := (($bitcast ($int<7>) f2_exp_biased ) - 15) $buffering 1
  $volatile exp_ab := (exp_a + exp_b) $buffering 1
  $volatile sign_result := (sign_f1 ^ sign_f2) $buffering 1
  $volatile f1_frac := (ONE_1 && f1_fraction) $buffering 1
  $volatile f2_frac := (ONE_1 && f2_fraction) $buffering 1
  frac_result_ext := (($bitcast ($uint<22>) f1_frac ) * ($bitcast ($uint<22>) f2_frac )) $buffering 1// bits of buffering = 22. 
  $volatile shift_by_one := (frac_result_ext [] 21 ) $buffering 1
  $volatile frac_result := ( $mux shift_by_one ( $slice frac_result_ext 20 11 )   ( $slice frac_result_ext 19 10 )  )  $buffering 1
  $volatile adjusted_exponent := ( $mux shift_by_one (exp_ab + 1 )  exp_ab )  $buffering 1
  $volatile exponent_result := ($bitcast ($uint<5>) (adjusted_exponent + 15) ) $buffering 1
  $volatile 	$call check_fh_exponent_overflow (adjusted_exponent ) (overflow underflow ) 
  result := ( $mux ((f1_inf | f2_inf) | overflow) ( $call getHalfInf (sign_result ) )  ( $mux (f1_nan | f2_nan) ( $call getHalfNan (sign_result ) )  ( $mux (f1_zero | underflow) ( $call getHalfZero (sign_result ) )  ((sign_result && exponent_result) && frac_result) )  )  )  $buffering 1// bits of buffering = 16. 
  $attribute delay 2
}

$module [normalize_32]
$in ( fract : $uint<24>   expon : $int<10>  )
$out ( fract_norm : $uint<24>   expon_norm : $int<10>  )
$is
{
  $volatile 	$call find_left_24 (fract ) (index found ) 
  $volatile shiftx := (23  - ($bitcast ($uint<6>) index )) $buffering 1
  $volatile 	$call i24_sll (fract ( $slice shiftx 4 0 )  ) (fraction_norm ) 
  $volatile exp_shift := ($bitcast ($int<10>) shiftx ) $buffering 1
  fract_norm := fraction_norm $buffering 1// bits of buffering = 24. 
  expon_norm := (expon - exp_shift) $buffering 1// bits of buffering = 10. 
}

$volatile $module [short_divide_24_core]
$in ( divisorx1 : $uint<26>   divisorx2 : $uint<26>   divisorx3 : $uint<26>   P : $uint<26>   A : $uint<30>  )
$out ( P_shift : $uint<26>   A_shift : $uint<30>  )
$is
{
  $volatile P_23_0 := ( $slice P 23 0 )  $buffering 1
  $volatile A_29_28 := ( $slice A 29 28 )  $buffering 1
  $volatile P_shift_start := (P_23_0 && A_29_28) $buffering 1
  $volatile 	$call comparison_greater_equal_less_26 (P_shift_start divisorx1 ) (cond_greater_than_B cond_less_than_B ) 
  $volatile 	$call comparison_greater_equal_less_26 (P_shift_start divisorx2 ) (cond_greater_than_2B cond_lesser_than_2B ) 
  $volatile 	$call comparison_greater_equal_less_26 (P_shift_start divisorx3 ) (cond_greater_than_3B cond_lesser_than_3B ) 
  $volatile condition_1 := cond_greater_than_2B $buffering 1
  $volatile condition_0 := ((cond_greater_than_2B & cond_greater_than_3B) | (cond_lesser_than_2B & cond_greater_than_B)) $buffering 1
  $volatile diff_operand := ( $mux cond_greater_than_3B divisorx3  ( $mux cond_greater_than_2B divisorx2  ( $mux cond_greater_than_B divisorx1  ZERO_26 )  )  )  $buffering 1
  $volatile A_shift := ((( $slice A 27 0 )  && condition_1) && condition_0) $buffering 1
  $volatile P_shift := (P_shift_start - diff_operand) $buffering 1
}

$operator $module [short_divide_24_pipelined_optimised]
$in ( dividend : $uint<24>   divisor_24 : $uint<24>  )
$out ( quo : $uint<29>  )
$is
{
  divisorx2 := ($bitcast ($uint<26>) (divisor_24 && ZERO_1) ) $buffering 2// bits of buffering = 52. 
  divisorx1 := ($bitcast ($uint<26>) divisor_24 ) $buffering 2// bits of buffering = 52. 
  divisorx3 := (($bitcast ($uint<26>) (divisor_24 && ZERO_1) ) + ($bitcast ($uint<26>) divisor_24 )) $buffering 2// bits of buffering = 52. 
  $branchblock [loop]
  {
    $dopipeline $depth 3 $buffering 2
    $fullrate 
    $merge $entry $loopback 
    $phi N := 			  ($bitcast ($uint<6>) 0  ) $on   $entry 			  NN_1 $on   $loopback 
    // type of target is $uint<6>
    $phi P := 			  next_P_1 $on   $loopback 			  (ZERO_4 && ( $slice dividend 23 2 ) ) $on   $entry 
    // type of target is $uint<26>
    $phi A := 			  (( $slice dividend 1 0 )  && ZERO_28) $on   $entry 			  next_A_1 $on   $loopback 
    // type of target is $uint<30>
    $endmerge
    $volatile 			$call short_divide_24_core (divisorx1 divisorx2 divisorx3 P A ) (P_shift_0 A_shift_0 ) 
    $volatile next_P_0 := P_shift_0 $buffering 1
    $volatile next_A_0 := A_shift_0 $buffering 1
    $volatile NN_0 := (N + 1 ) $buffering 1
    $volatile 			$call short_divide_24_core (divisorx1 divisorx2 divisorx3 next_P_0 next_A_0 ) (P_shift_1 A_shift_1 ) 
    $volatile next_P_1 := P_shift_1 $buffering 1
    $volatile next_A_1 := A_shift_1 $buffering 1
    $volatile NN_1 := (NN_0 + 1 ) $buffering 1
    $volatile continue_flag := (N <= 12 ) $buffering 1
    $while continue_flag
  }
  ( next_A_0 => A )
  quo := ( $slice A 28 0 )  $buffering 2// bits of buffering = 58. 
}

$module [fpdivide32]
$in ( f1_s : $float<8,23>   f2_s : $float<8,23>  )
$out ( f1BYf2 : $float<8,23>  )
$is
{
  $volatile uf1_s := ($bitcast ($uint<32>) f1_s ) $buffering 1
  $volatile uf2_s := ($bitcast ($uint<32>) f2_s ) $buffering 1
  $volatile sign_uf1_s := (uf1_s [] 31 ) $buffering 1
  $volatile sign_uf2_s := (uf2_s [] 31 ) $buffering 1
  $volatile sign_result := (sign_uf1_s ^ sign_uf2_s) $buffering 1
  $volatile 	$call classFp32 (f1_s ) (f1_s_pos_normal f1_s_neg_normal f1_s_pos_denormal f1_s_neg_denormal f1_s_qnan f1_s_snan f1_s_pos_inf f1_s_neg_inf f1_s_pos_zero f1_s_neg_zero ) 
  $volatile 	$call classFp32 (f2_s ) (f2_s_pos_normal f2_s_neg_normal f2_s_pos_denormal f2_s_neg_denormal f2_s_qnan f2_s_snan f2_s_pos_inf f2_s_neg_inf f2_s_pos_zero f2_s_neg_zero ) 
  $volatile f1_s_zero := (f1_s_pos_zero | f1_s_neg_zero) $buffering 1
  $volatile f2_s_zero := (f2_s_pos_zero | f2_s_neg_zero) $buffering 1
  $volatile f1_s_normal := (f1_s_pos_normal | f1_s_neg_normal) $buffering 1
  $volatile f2_s_normal := (f2_s_pos_normal | f2_s_neg_normal) $buffering 1
  $volatile f1_s_denormal := (f1_s_pos_denormal | f1_s_neg_denormal) $buffering 1
  $volatile f2_s_denormal := (f2_s_pos_denormal | f2_s_neg_denormal) $buffering 1
  $volatile f1_s_inf := (f1_s_pos_inf | f1_s_neg_inf) $buffering 1
  $volatile f2_s_inf := (f2_s_pos_inf | f2_s_neg_inf) $buffering 1
  $volatile 	$call break_number_32 (uf1_s f1_s_normal f1_s_denormal f1_s_qnan f1_s_snan f1_s_inf f1_s_zero DENORM ) (f1_s_frac f1_s_expon ) 
  $volatile 	$call break_number_32 (uf2_s f2_s_normal f2_s_denormal f2_s_qnan f2_s_snan f2_s_inf f2_s_zero DENORM ) (f2_s_frac f2_s_expon ) 
  $guard (f1_s_denormal) $call normalize_32 (f1_s_frac f1_s_expon ) (f1_s_frac_norm f1_s_expon_norm ) 
  $guard (f2_s_denormal) $call normalize_32 (f2_s_frac f2_s_expon ) (f2_s_frac_norm f2_s_expon_norm ) 
  $volatile f1_fraction := ( $mux f1_s_denormal f1_s_frac_norm  f1_s_frac )  $buffering 1
  $volatile f2_fraction := ( $mux f2_s_denormal f2_s_frac_norm  f2_s_frac )  $buffering 1
  $volatile f1_expon := ( $mux f1_s_denormal f1_s_expon_norm  f1_s_expon )  $buffering 1
  $volatile f2_expon := ( $mux f2_s_denormal f2_s_expon_norm  f2_s_expon )  $buffering 1
  $volatile expon_difference := (f1_expon - f2_expon) $buffering 1
  $call short_divide_24_pipelined_optimised (f1_fraction f2_fraction ) (quotient ) 
  $volatile quotient_MSB := (quotient [] 28 ) $buffering 1
  $volatile quotient_LSB := (quotient [] 5 ) $buffering 1
  $volatile mantissa_24_before_rounding := ( $mux quotient_MSB ( $slice quotient 28 5 )   ( $slice quotient 27 4 )  )  $buffering 1
  $volatile guard_bits_5 := ( $slice quotient 4 0 )  $buffering 1
  $volatile guard_bits_4 := ( $slice quotient 3 0 )  $buffering 1
  $volatile guard_5_up_round_condition := (guard_bits_5 >= 16 ) $buffering 1
  $volatile guard_4_up_round_condition := (guard_bits_4 >= 8 ) $buffering 1
  $volatile upround_the_mantissa := ( $mux quotient_MSB guard_5_up_round_condition  guard_4_up_round_condition )  $buffering 1
  $volatile mantissa_24_incremented := (mantissa_24_before_rounding + 1 ) $buffering 1
  $volatile mantissa_24_incr_top_bit := (mantissa_24_incremented [] 23 ) $buffering 1
  $volatile mantissa_23 := ( $mux upround_the_mantissa ( $mux mantissa_24_incr_top_bit ( $slice mantissa_24_incremented 22 0 )   ZERO_23 )   ( $slice mantissa_24_before_rounding 22 0 )  )  $buffering 1
  $volatile exponent_adjustment := (( $mux quotient_MSB 0   (($bitcast ($int<10>) 0  ) - 1 ) )  + ( $mux mantissa_24_incr_top_bit 0   ($bitcast ($int<10>) 1  ) ) ) $buffering 1
  $volatile expon_bias := expbase_127 $buffering 1
  $volatile exponent_before_round := (expon_difference + expon_bias) $buffering 1
  $volatile exponent := (exponent_before_round + exponent_adjustment) $buffering 1
  $volatile exponent_unbiased := (exponent - expon_bias) $buffering 1
  $volatile exponent_8 := ($bitcast ($uint<8>) exponent ) $buffering 1
  $volatile mantissa := mantissa_23 $buffering 1
  $volatile overflow := (exponent_unbiased > 127 ) $buffering 1
  $volatile underflow := (exponent_unbiased < -126 ) $buffering 1
  $volatile qnan_condition := (((f1_s_qnan | f1_s_snan) | f2_s_qnan) | ((f2_s_snan | (f2_s_inf & ((f1_s_inf | f1_s_snan) | f1_s_qnan))) | (f2_s_zero & ((f1_s_zero | f1_s_snan) | f1_s_qnan)))) $buffering 1
  $volatile zero_condition := (( ~ qnan_condition ) & ((f1_s_zero & ( ~ f2_s_zero )) | (( ~ f1_s_qnan ) & f2_s_inf))) $buffering 1
  $volatile inf_condition := ((( ~ zero_condition ) & ( ~ qnan_condition )) & (((f2_s_zero & ((f1_s_normal | f1_s_denormal) | f1_s_inf)) | (f1_s_inf & (f2_s_normal | f2_s_denormal))) | overflow)) $buffering 1
  $volatile needs_denormalization := underflow $buffering 1
  $volatile denorm_shift_amount := ((0  - 126 ) - exponent_unbiased) $buffering 1
  $volatile is_denormalizable := (((underflow & (denorm_shift_amount <= 24 )) & ( ~ inf_condition )) & (( ~ qnan_condition ) & ( ~ zero_condition ))) $buffering 1
  $volatile denorm_to_zero := (((underflow & (denorm_shift_amount > 24 )) & ( ~ inf_condition )) & (( ~ qnan_condition ) & ( ~ zero_condition ))) $buffering 1
  $volatile exp_shift := (0  - exponent_unbiased) $buffering 1
  $volatile p := ((ONE_1 && mantissa) && ZERO_8) $buffering 1
  $volatile q := ($bitcast ($uint<5>) denorm_shift_amount ) $buffering 1
  $volatile 	$call i32_srl (p q ) (shifted ) 
  mantissa_denorm_final := ( $slice shifted 30 8 )  $buffering 1// bits of buffering = 23. 
  $volatile result_denormal := ((sign_result && ZERO_8) && mantissa_denorm_final) $buffering 1
  $volatile result_normal := ((sign_result && exponent_8) && mantissa) $buffering 1
  $volatile result_qnan := ((sign_result && ALL_ONE_8) && (ONE_1 && ZERO_22)) $buffering 1
  $volatile result_zero := (sign_result && ZERO_31) $buffering 1
  $volatile result_infinity := ((sign_result && ALL_ONE_8) && ZERO_23) $buffering 1
  $volatile underflow_denorm := (underflow & is_denormalizable) $buffering 1
  $volatile underflow_not_denorm := (underflow & ( ~ is_denormalizable )) $buffering 1
  $volatile normal_condition := (((( ~ zero_condition ) & ( ~ qnan_condition )) & (( ~ inf_condition ) & (f1_s_normal | f1_s_denormal))) & (((f2_s_normal | f2_s_denormal) & ( ~ overflow )) & ( ~ underflow ))) $buffering 1
  $volatile result := (((( $mux (zero_condition | denorm_to_zero) result_zero  _b0  )  | ( $mux qnan_condition result_qnan  _b0  ) ) | ( $mux inf_condition result_infinity  _b0  ) ) | (( $mux normal_condition result_normal  _b0  )  | ( $mux is_denormalizable result_denormal  _b0  ) )) $buffering 1
  $volatile f1BYf2 := ($bitcast ($float<8,23>) result ) $buffering 1
  $attribute delay 3
}

$volatile $module [make_new_estimate_32]
$in ( last_root_estimate : $uint<32>   last_residue : $uint<34>   last_shifted_index_word : $uint<32>  )
$out ( current_root_estimate : $uint<32>   current_residue : $uint<34>   current_residue_sign : $uint<1>  )
$is
{
  $report (fpdiv32bitwise make_new_estimate_32_in_args__ 	 last_root_estimate last_root_estimate 	 last_residue last_residue 	 last_shifted_index_word last_shifted_index_word )
  current_shifted_index_word := (ZERO_1 && ( $slice last_shifted_index_word 31 1 ) ) $buffering 1
  current_root_estimate := (last_root_estimate | current_shifted_index_word) $buffering 1
  current_shifted_index_word_right_shifted := (ZERO_1 && ( $slice current_shifted_index_word 31 1 ) ) $buffering 1
  current_increment := ((ZERO_1 && (last_root_estimate | current_shifted_index_word_right_shifted)) && ZERO_1) $buffering 1
  current_residue := (last_residue - current_increment) $buffering 1
  current_residue_sign := (last_residue < current_increment) $buffering 1
  $report (fpdiv32bitwise make_new_estimate_32_outargs 	 current_shifted_index_word current_shifted_index_word 	 current_root_estimate current_root_estimate 	 current_shifted_index_word_right_shifted current_shifted_index_word_right_shifted 	 current_increment current_increment 	 current_residue current_residue 	 current_residue_sign current_residue_sign )
}

$volatile $module [short_sqrt_32_core]
$in ( last_root_estimate : $uint<32>   last_residue : $uint<34>   last_shifted_index_word : $uint<32>   last_index : $uint<8>  )
$out ( next_root_estimate : $uint<32>   next_residue : $uint<34>   next_last_shifted_index_word : $uint<32>   sticky_flag : $uint<1>  )
$is
{
  current_index := ( $mux (last_index > 0 ) (last_index - 1 )  0  )  $buffering 1
  $report (fpdiv32bitwise short_sqrt_32_core_in_args 	 last_root_estimate last_root_estimate 	 last_residue last_residue 	 last_shifted_index_word last_shifted_index_word 	 last_index last_index 	 current_index current_index )
  $volatile 	$call make_new_estimate_32 (last_root_estimate last_residue last_shifted_index_word ) (current_root_estimate current_residue current_residue_sign ) 
  next_root_estimate := ( $mux ( ~ current_residue_sign ) current_root_estimate  last_root_estimate )  $buffering 1
  next_residue_before_shift := ( $mux ( ~ current_residue_sign ) current_residue  last_residue )  $buffering 1
  next_residue := (( $slice next_residue_before_shift 32 0 )  && ZERO_1) $buffering 1
  sticky_flag := (next_residue != 0 ) $buffering 1
  next_last_shifted_index_word := (ZERO_1 && ( $slice last_shifted_index_word 31 1 ) ) $buffering 1
  $report (fpdiv32bitwise short_sqrt_32_core_out_args 	 next_residue next_residue 	 next_root_estimate next_root_estimate 	 next_last_shifted_index_word next_last_shifted_index_word )
}

$operator $module [short_sqrt_32]
$in ( X : $uint<32>  )
$out ( sticky : $uint<1>   root_X : $uint<32>  )
$is
{
  $report (fpdiv32bitwise X__ 	 X X )
  $volatile start_index := 31  $buffering 1
  $report (fpdiv32bitwise start_index__ 	 start_index start_index )
  $volatile start_root_estimate := _h80000000  $buffering 1
  $report (fpdiv32bitwise start_root_estimate__ 	 start_root_estimate start_root_estimate )
  $volatile start_residue := (((( $slice X 31 30 )  - 1 ) && ( $slice X 29 0 ) ) && ZERO_2) $buffering 1
  $report (fpdiv32bitwise start_residue__ 	 start_residue start_residue )
  $volatile start_shifted_index_word := _h80000000  $buffering 1
  $report (fpdiv32bitwise start_shifted_index_word__ 	 start_shifted_index_word start_shifted_index_word )
  $branchblock [loop]
  {
    $dopipeline $depth 3 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi last_root_estimate := 			  start_root_estimate $on   $entry 			  next_root_estimate $on   $loopback 
    // type of target is $uint<32>
    $phi last_residue := 			  start_residue $on   $entry 			  next_last_residue $on   $loopback 
    // type of target is $uint<34>
    $phi last_shifted_index_word := 			  start_shifted_index_word $on   $entry 			  next_last_shifted_index_word $on   $loopback 
    // type of target is $uint<32>
    $phi last_index := 			  start_index $on   $entry 			  next_last_index $on   $loopback 
    // type of target is $uint<8>
    $endmerge
    $report (fpdiv32bitwise short_sqrt_32_status 			 last_index last_index 			 last_root_estimate last_root_estimate 			 last_residue last_residue 			 last_shifted_index_word last_shifted_index_word )
    $volatile next_last_index_0 := ( $mux (last_index > 0 ) (last_index - 1 )  0  )  $buffering 1
    $volatile next_last_index_1 := ( $mux (last_index > 1 ) (last_index - 2 )  0  )  $buffering 1
    $volatile next_last_index := ( $mux (last_index > 2 ) (last_index - 3 )  0  )  $buffering 1
    $volatile continue_flag := ((next_last_index > 0 ) & (last_residue != 0 )) $buffering 1
    $volatile 			$call short_sqrt_32_core (last_root_estimate last_residue last_shifted_index_word last_index ) (next_root_estimate_0 next_last_residue_0 next_last_shifted_index_word_0 sticky_flag_0 ) 
    $volatile 			$call short_sqrt_32_core (next_root_estimate_0 next_last_residue_0 next_last_shifted_index_word_0 next_last_index_0 ) (next_root_estimate_1 next_last_residue_1 next_last_shifted_index_word_1 sticky_flag_1 ) 
    $volatile 			$call short_sqrt_32_core (next_root_estimate_1 next_last_residue_1 next_last_shifted_index_word_1 next_last_index_1 ) (next_root_estimate next_last_residue next_last_shifted_index_word sticky_flag ) 
    $while continue_flag
  }
  ( next_root_estimate => root_estimate  sticky_flag => sticky_out )
  sticky := sticky_out $buffering 2// bits of buffering = 2. 
  root_X := root_estimate $buffering 2// bits of buffering = 64. 
  $attribute output_buffering 0
}

$volatile $module [round_e_32]
$in ( sticky_flag : $uint<1>   signed_unbiased_exponent : $int<13>   padded_mantissa : $uint<32>  )
$out ( result : $float<8,23>  )
$is
{
  ue_13 := ($bitcast ($uint<13>) signed_unbiased_exponent ) $buffering 1
  m_62 := (( $slice padded_mantissa 30 0 )  && ZERO_31) $buffering 1
  $report (round_e_32 in_args__ 	 signed_unbiased_exponent signed_unbiased_exponent 	 padded_mantissa padded_mantissa 	 ue_13 ue_13 	 m_62 m_62 )
  $volatile 	$call round_32_extn (sticky_flag ZERO_1 ue_13 m_62 ) (r_ue_13 r_m_23 ) 
  ur32 := ((ZERO_1 && ( $slice r_ue_13 7 0 ) ) && r_m_23) $buffering 1
  result := ($bitcast ($float<8,23>) ur32 ) $buffering 1
  $report (round_e_32 out_args__ 	 ur32 ur32 )
}

$module [fpsqrt32_bit_wise]
$in ( a : $float<8,23>  )
$out ( sqrt_a : $float<8,23>  )
$is
{
  $volatile 	$call classify_and_prepare_32 (a ) (e_e e_m special_case special_case_result ) 
  $report (fpdiv32bitwise fpsqrt32_bit_wise_in_args__ 	 a a 	 e_e e_e 	 e_m e_m 	 special_case special_case 	 special_case_result special_case_result )
  $guard (~special_case) $call short_sqrt_32 (e_m ) (sticky s_e_m ) 
  $guard (~special_case) $report (fpdiv32bitwise fpsqrt32_bit_wise_post_short_sqrt 	 sticky sticky 	 e_m e_m 	 s_e_m s_e_m )
  $volatile s_e_e := ( $mux ((e_e < 0 ) & (e_e == -1 )) 0   (e_e >> 1 ) )  $buffering 1
  $report (fpdiv32bitwise fpsqrt32_bit_wise_to_round 	 s_e_e s_e_e 	 s_e_m s_e_m )
  $volatile sticky_qualified := ( $mux special_case _b0   sticky )  $buffering 1
  $volatile s_e_e_qualified := ( $mux special_case _b0   s_e_e )  $buffering 1
  $volatile s_e_m_qualified := ( $mux special_case _b0   s_e_m )  $buffering 1
  $volatile 	$call round_e_32 (sticky_qualified s_e_e_qualified s_e_m_qualified ) (fsqrt32_normalized_result ) 
  $volatile ur := ($bitcast ($uint<32>) fsqrt32_normalized_result ) $buffering 1
  $report (fpdiv32bitwise fpsqrt32_bit_wise_from_round 	 ur ur )
  $volatile sqrt_a := ( $mux special_case special_case_result  fsqrt32_normalized_result )  $buffering 1
  $attribute delay 3
}

$volatile $module [fcmpBase]
$in ( a_zero : $uint<1>   a_nan : $uint<1>   a_sign : $uint<1>   b_zero : $uint<1>   b_nan : $uint<1>   b_sign : $uint<1>   a_b : $uint<1>   b_a : $uint<1>   u_a_e_b : $uint<1>  )
$out ( cmp_flags : $uint<2>  )
$is
{
  a_eq_b := (u_a_e_b | (a_zero & b_zero)) $buffering 1
  a_incomp_b := (a_nan | b_nan) $buffering 1
  a_lt_b := ((( ~ a_incomp_b ) & ( ~ a_eq_b )) & ((a_sign & ( ~ b_sign )) | ((a_sign == b_sign) & ( $mux a_sign b_a  a_b ) ))) $buffering 1
  a_gt_b := ((( ~ a_incomp_b ) & ( ~ a_eq_b )) & ( ~ a_lt_b )) $buffering 1
  cmp_flags := ((( $mux a_eq_b 0   _b0  )  | ( $mux a_lt_b 1   _b0  ) ) | (( $mux a_gt_b 2   _b0  )  | ( $mux a_incomp_b 3   _b0  ) )) $buffering 1
}

$volatile $module [fpcmp32]
$in ( a : $float<8,23>   b : $float<8,23>   e_flag : $uint<1>  )
$out ( cmp_flags : $uint<2>  )
$is
{
  $volatile 	$call classify_32 (a ) (a_zero a_normal a_denormal a_inf a_nan ) 
  $volatile 	$call classify_32 (b ) (b_zero b_normal b_denormal b_inf b_nan ) 
  ua := ($bitcast ($uint<32>) a ) $buffering 1
  ub := ($bitcast ($uint<32>) b ) $buffering 1
  a_sign := (ua [] 31 ) $buffering 1
  a_rest := ( $slice ua 30 0 )  $buffering 1
  b_sign := (ub [] 31 ) $buffering 1
  b_rest := ( $slice ub 30 0 )  $buffering 1
  $volatile 	$call compare32 ((($bitcast ($uint<1>) _b0 ) && a_rest) (($bitcast ($uint<1>) _b0 ) && b_rest) ) (G E ) 
  a_b := ( ~ (G | E) ) $buffering 1
  b_a := G $buffering 1
  u_a_e_b := ((a_sign == b_sign) & E) $buffering 1
  $volatile 	$call fcmpBase (a_zero a_nan a_sign b_zero b_nan b_sign a_b b_a u_a_e_b ) (cmp_flags ) 
  $report (fpunit_exec fpcmp32_trace__ 	 a a 	 b b 	 cmp_flags cmp_flags )
}

$volatile $module [i53_srl]
$in ( X : $uint<53>   S : $uint<6>  )
$out ( Y : $uint<53>  )
$is
{
  X0 := ( $mux (S [] 0 ) (ZERO_1 && ( $slice X 52 1 ) )  X )  $buffering 1
  X1 := ( $mux (S [] 1 ) (ZERO_2 && ( $slice X0 52 2 ) )  X0 )  $buffering 1
  X2 := ( $mux (S [] 2 ) (ZERO_4 && ( $slice X1 52 4 ) )  X1 )  $buffering 1
  X3 := ( $mux (S [] 3 ) (ZERO_8 && ( $slice X2 52 8 ) )  X2 )  $buffering 1
  X4 := ( $mux (S [] 4 ) (ZERO_16 && ( $slice X3 52 16 ) )  X3 )  $buffering 1
  Y := ( $mux (S [] 5 ) (ZERO_32 && ( $slice X4 52 32 ) )  X4 )  $buffering 1
}

$pipeline $depth 3 $buffering 1 $fullrate $operator $module [fdtoi_op]
$in ( X : $float<11,52>  )
$out ( Y : $int<32>  )
$is
{
  $volatile 	$call classify_64 (X ) (is_zero is_normal is_denormal is_inf is_nan ) 
  $volatile uX := ($bitcast ($uint<64>) X ) $buffering 1
  $volatile X_sign := (uX [] 63 ) $buffering 1
  $volatile X_exponent := ( $slice uX 62 52 )  $buffering 1
  $volatile bias := ( $mux is_denormal exp_base_1022  exp_base_1023 )  $buffering 1
  $volatile unbiased_exponent := (($bitcast ($int<13>) X_exponent ) - bias) $buffering 1
  $volatile X_mantissa := (($bitcast ($uint<1>) _b1 ) && ( $slice uX 51 0 ) ) $buffering 1
  $volatile zero_result := ((is_zero | is_denormal) | (is_normal & (unbiased_exponent < 0 ))) $buffering 1
  $volatile dtoi_overflow := ((is_nan | is_inf) | (is_normal & (unbiased_exponent > 30 ))) $buffering 1
  $volatile shift_amount := ($bitcast ($uint<6>) (52  - unbiased_exponent) ) $buffering 1
  $volatile 	$call i53_srl (X_mantissa shift_amount ) (shifted_X_mantissa ) 
  normal_u_result := (($bitcast ($uint<1>) _b0 ) && ( $slice shifted_X_mantissa 30 0 ) ) $buffering 1// bits of buffering = 32. 
  $volatile normal_s_result := ( $mux X_sign (( ~ normal_u_result ) + ($bitcast ($uint<32>) _b1 ))  normal_u_result )  $buffering 1
  $volatile result_infinity := ( $mux X_sign ($bitcast ($uint<32>) _h80000000  )  ($bitcast ($uint<32>) _h7fffffff  ) )  $buffering 1
  Y := ((( $mux zero_result ($bitcast ($int<32>) ($bitcast ($uint<32>) _b0 ) )  _b0  )  | ( $mux dtoi_overflow ($bitcast ($int<32>) result_infinity )  _b0  ) ) | ( $mux (is_normal & ( ~ zero_result )) ($bitcast ($int<32>) normal_s_result )  _b0  ) ) $buffering 1// bits of buffering = 32. 
  $attribute delay 2
}

$module [normalize_64]
$in ( fract : $uint<53>   expon : $int<13>  )
$out ( fract_norm : $uint<53>   expon_norm : $int<13>  )
$is
{
  $volatile fract_64 := ($bitcast ($uint<64>) fract ) $buffering 1
  $volatile 	$call find_leftmost_64 (fract_64 ) (index found ) 
  $volatile shiftx := (FRACTION_WIDTH_52 - index) $buffering 1
  $volatile 	$call i64_sll (fract_64 ($bitcast ($uint<6>) shiftx ) ) (fraction_norm ) 
  $volatile exp_shift := ($bitcast ($int<13>) shiftx ) $buffering 1
  fract_norm := ( $slice fraction_norm 52 0 )  $buffering 1// bits of buffering = 53. 
  expon_norm := (expon - exp_shift) $buffering 1// bits of buffering = 13. 
}

$volatile $module [short_divide_53_core]
$in ( divisorx1 : $uint<55>   divisorx2 : $uint<55>   divisorx3 : $uint<55>   P : $uint<55>   A : $uint<106>  )
$out ( next_P : $uint<55>   next_A : $uint<106>  )
$is
{
  P_52_0 := ( $slice P 52 0 )  $buffering 1
  A_105_104 := ( $slice A 105 104 )  $buffering 1
  P_shift_start := (P_52_0 && A_105_104) $buffering 1
  $volatile 	$call comparison_greater_equal_less_55 (P_shift_start divisorx1 ) (cond_greater_than_B cond_less_than_B ) 
  $volatile 	$call comparison_greater_equal_less_55 (P_shift_start divisorx2 ) (cond_greater_than_2B cond_lesser_than_2B ) 
  $volatile 	$call comparison_greater_equal_less_55 (P_shift_start divisorx3 ) (cond_greater_than_3B cond_lesser_than_3B ) 
  condition_1 := cond_greater_than_2B $buffering 1
  condition_0 := ((cond_greater_than_2B & cond_greater_than_3B) | (cond_lesser_than_2B & cond_greater_than_B)) $buffering 1
  diff_operand := ( $mux cond_greater_than_3B divisorx3  ( $mux cond_greater_than_2B divisorx2  ( $mux cond_greater_than_B divisorx1  ZERO_55 )  )  )  $buffering 1
  next_P := (P_shift_start - diff_operand) $buffering 1
  next_A := ((( $slice A 103 0 )  && condition_1) && condition_0) $buffering 1
}

$operator $module [short_divide_53_pipelined_optimised]
$in ( dividend : $uint<53>   divisor : $uint<53>  )
$out ( quo : $uint<58>  )
$is
{
  divisorx2 := ($bitcast ($uint<55>) (divisor && ZERO_1) ) $buffering 2// bits of buffering = 110. 
  divisorx1 := ($bitcast ($uint<55>) divisor ) $buffering 2// bits of buffering = 110. 
  divisorx3 := (($bitcast ($uint<55>) divisor ) + ($bitcast ($uint<55>) (divisor && ZERO_1) )) $buffering 2// bits of buffering = 110. 
  $branchblock [loop]
  {
    $dopipeline $depth 7 $buffering 2
    $fullrate 
    $merge $entry $loopback 
    $phi N := 			  ($bitcast ($uint<8>) 0  ) $on   $entry 			  NN_1 $on   $loopback 
    // type of target is $uint<8>
    $phi P := 			  (ZERO_4 && ( $slice dividend 52 2 ) ) $on   $entry 			  next_P_1 $on   $loopback 
    // type of target is $uint<55>
    $phi A := 			  (( $slice dividend 1 0 )  && ZERO_104) $on   $entry 			  next_A_1 $on   $loopback 
    // type of target is $uint<106>
    $endmerge
    $volatile 			$call short_divide_53_core (divisorx1 divisorx2 divisorx3 P A ) (next_P_0_v next_A_0_v ) 
    $volatile NN_0 := (N + 1 ) $buffering 1
    $volatile next_P_0 := next_P_0_v $buffering 1
    $volatile next_A_0 := next_A_0_v $buffering 1
    $volatile 			$call short_divide_53_core (divisorx1 divisorx2 divisorx3 next_P_0 next_A_0 ) (next_P_1_v next_A_1_v ) 
    $volatile NN_1 := (NN_0 + 1 ) $buffering 1
    $volatile next_P_1 := next_P_1_v $buffering 1
    $volatile next_A_1 := next_A_1_v $buffering 1
    $volatile continue_flag := (N <= 26 ) $buffering 1
    $while continue_flag
  }
  ( next_A_1 => A )
  quo := ( $slice A 58 1 )  $buffering 2// bits of buffering = 116. 
}

$module [fpdivide64]
$in ( f1_d : $float<11,52>   f2_d : $float<11,52>  )
$out ( f1BYf2 : $float<11,52>  )
$is
{
  $volatile uf1_d := ($bitcast ($uint<64>) f1_d ) $buffering 1
  $volatile uf2_d := ($bitcast ($uint<64>) f2_d ) $buffering 1
  $volatile sign_uf1_d := (uf1_d [] 63 ) $buffering 1
  $volatile sign_uf2_d := (uf2_d [] 63 ) $buffering 1
  $volatile sign_result := (sign_uf1_d ^ sign_uf2_d) $buffering 1
  $volatile 	$call classFp64 (f1_d ) (f1_d_pos_normal f1_d_neg_normal f1_d_pos_denormal f1_d_neg_denormal f1_d_qnan f1_d_snan f1_d_pos_inf f1_d_neg_inf f1_d_pos_zero f1_d_neg_zero ) 
  $volatile 	$call classFp64 (f2_d ) (f2_d_pos_normal f2_d_neg_normal f2_d_pos_denormal f2_d_neg_denormal f2_d_qnan f2_d_snan f2_d_pos_inf f2_d_neg_inf f2_d_pos_zero f2_d_neg_zero ) 
  $volatile f1_d_zero := (f1_d_pos_zero | f1_d_neg_zero) $buffering 1
  $volatile f2_d_zero := (f2_d_pos_zero | f2_d_neg_zero) $buffering 1
  $volatile f1_d_normal := (f1_d_pos_normal | f1_d_neg_normal) $buffering 1
  $volatile f2_d_normal := (f2_d_pos_normal | f2_d_neg_normal) $buffering 1
  $volatile f1_d_denormal := (f1_d_pos_denormal | f1_d_neg_denormal) $buffering 1
  $volatile f2_d_denormal := (f2_d_pos_denormal | f2_d_neg_denormal) $buffering 1
  $volatile f1_d_inf := (f1_d_pos_inf | f1_d_neg_inf) $buffering 1
  $volatile f2_d_inf := (f2_d_pos_inf | f2_d_neg_inf) $buffering 1
  $volatile 	$call break_number_64 (uf1_d f1_d_normal f1_d_denormal f1_d_qnan f1_d_snan f1_d_inf f1_d_zero DENORM ) (f1_d_frac f1_d_expon ) 
  $volatile 	$call break_number_64 (uf2_d f2_d_normal f2_d_denormal f2_d_qnan f2_d_snan f2_d_inf f2_d_zero DENORM ) (f2_d_frac f2_d_expon ) 
  $guard (f1_d_denormal) $call normalize_64 (f1_d_frac f1_d_expon ) (f1_d_frac_norm f1_d_expon_norm ) 
  $guard (f2_d_denormal) $call normalize_64 (f2_d_frac f2_d_expon ) (f2_d_frac_norm f2_d_expon_norm ) 
  $volatile f1_fraction := ( $mux f1_d_denormal f1_d_frac_norm  f1_d_frac )  $buffering 1
  $volatile f2_fraction := ( $mux f2_d_denormal f2_d_frac_norm  f2_d_frac )  $buffering 1
  $volatile f1_expon := ( $mux f1_d_denormal f1_d_expon_norm  f1_d_expon )  $buffering 1
  $volatile f2_expon := ( $mux f2_d_denormal f2_d_expon_norm  f2_d_expon )  $buffering 1
  $volatile expon_difference := (f1_expon - f2_expon) $buffering 1
  $call short_divide_53_pipelined_optimised (f1_fraction f2_fraction ) (quotient ) 
  $volatile quotient_MSB := (quotient [] 57 ) $buffering 1
  $volatile quotient_LSB := (quotient [] 5 ) $buffering 1
  $volatile mantissa_53_before_rounding := ( $mux quotient_MSB ( $slice quotient 57 5 )   ( $slice quotient 56 4 )  )  $buffering 1
  $volatile guard_bits_5 := ( $slice quotient 4 0 )  $buffering 1
  $volatile guard_bits_4 := ( $slice quotient 3 0 )  $buffering 1
  $volatile guard_5_up_round_condition := (guard_bits_5 >= 16 ) $buffering 1
  $volatile guard_4_up_round_condition := (guard_bits_4 >= 8 ) $buffering 1
  $volatile upround_the_mantissa := ( $mux quotient_MSB guard_5_up_round_condition  guard_4_up_round_condition )  $buffering 1
  $volatile mantissa_53_incremented := (mantissa_53_before_rounding + 1 ) $buffering 1
  $volatile mantissa_53_incr_top_bit := (mantissa_53_incremented [] 52 ) $buffering 1
  $volatile mantissa_52 := ( $mux upround_the_mantissa ( $mux mantissa_53_incr_top_bit ( $slice mantissa_53_incremented 51 0 )   ZERO_52 )   ( $slice mantissa_53_before_rounding 51 0 )  )  $buffering 1
  $volatile exponent_adjustment := (( $mux quotient_MSB 0   (($bitcast ($int<13>) 0  ) - 1 ) )  + ( $mux mantissa_53_incr_top_bit 0   ($bitcast ($int<13>) 1  ) ) ) $buffering 1
  $volatile expon_bias := expbase_1023 $buffering 1
  $volatile exponent_before_round := (expon_difference + expon_bias) $buffering 1
  $volatile exponent := (exponent_before_round + exponent_adjustment) $buffering 1
  $volatile exponent_unbiased := (exponent - expon_bias) $buffering 1
  $volatile exponent_11 := ($bitcast ($uint<11>) exponent ) $buffering 1
  $volatile mantissa := mantissa_52 $buffering 1
  $volatile overflow := (exponent_unbiased > 1023 ) $buffering 1
  $volatile underflow := (exponent_unbiased < -1022 ) $buffering 1
  $volatile qnan_condition := (((f2_d_qnan | f2_d_snan) | f1_d_qnan) | ((f1_d_snan | (f2_d_inf & ((f1_d_inf | f1_d_snan) | f1_d_qnan))) | (f2_d_zero & ((f1_d_zero | f1_d_snan) | f1_d_qnan)))) $buffering 1
  $volatile zero_condition := (( ~ qnan_condition ) & ((f1_d_zero & ( ~ f2_d_zero )) | (( ~ f1_d_qnan ) & f2_d_inf))) $buffering 1
  $volatile inf_condition := ((( ~ zero_condition ) & ( ~ qnan_condition )) & (((f2_d_zero & ((f1_d_normal | f1_d_denormal) | f1_d_inf)) | (f1_d_inf & (f2_d_normal | f2_d_denormal))) | overflow)) $buffering 1
  $volatile needs_denormalization := underflow $buffering 1
  $volatile denorm_shift_amount := ((0  - 1022 ) - exponent_unbiased) $buffering 1
  $volatile is_denormalizable := (((underflow & (denorm_shift_amount <= 52 )) & ( ~ inf_condition )) & (( ~ qnan_condition ) & ( ~ zero_condition ))) $buffering 1
  $volatile denorm_to_zero := (((underflow & (denorm_shift_amount > 52 )) & ( ~ inf_condition )) & (( ~ qnan_condition ) & ( ~ zero_condition ))) $buffering 1
  $volatile exp_shift := (0  - exponent_unbiased) $buffering 1
  $volatile p := ((ONE_1 && mantissa) && ZERO_11) $buffering 1
  $volatile q := ($bitcast ($uint<6>) denorm_shift_amount ) $buffering 1
  $volatile 	$call i64_srl (p q ) (shifted ) 
  mantissa_denorm_final := ( $slice shifted 62 11 )  $buffering 1// bits of buffering = 52. 
  $volatile result_denormal := ((sign_result && ZERO_11) && mantissa_denorm_final) $buffering 1
  $volatile result_normal := ((sign_result && exponent_11) && mantissa) $buffering 1
  $volatile result_qnan := ((sign_result && ALL_ONE_11) && (ONE_1 && ZERO_51)) $buffering 1
  $volatile result_zero := (sign_result && ZERO_63) $buffering 1
  $volatile result_infinity := ((sign_result && ALL_ONE_11) && ZERO_52) $buffering 1
  $volatile normal_condition := (((( ~ zero_condition ) & ( ~ qnan_condition )) & (( ~ inf_condition ) & (f1_d_normal | f1_d_denormal))) & (((f2_d_normal | f2_d_denormal) & ( ~ overflow )) & ( ~ underflow ))) $buffering 1
  $volatile result := (((( $mux (zero_condition | denorm_to_zero) result_zero  _b0  )  | ( $mux qnan_condition result_qnan  _b0  ) ) | ( $mux inf_condition result_infinity  _b0  ) ) | (( $mux normal_condition result_normal  _b0  )  | ( $mux is_denormalizable result_denormal  _b0  ) )) $buffering 1
  $volatile f1BYf2 := ($bitcast ($float<11,52>) result ) $buffering 1
  $attribute delay 3
}

$volatile $module [make_new_estimate_56]
$in ( last_root_estimate : $uint<56>   last_residue : $uint<58>   last_shifted_index_word : $uint<56>  )
$out ( current_root_estimate : $uint<56>   current_residue : $uint<58>   current_residue_sign : $uint<1>  )
$is
{
  $report (fpdiv64bitwise make_new_estimate_56_in_args__ 	 last_root_estimate last_root_estimate 	 last_residue last_residue 	 last_shifted_index_word last_shifted_index_word )
  current_shifted_index_word := (ZERO_1 && ( $slice last_shifted_index_word 55 1 ) ) $buffering 1
  current_root_estimate := (last_root_estimate | current_shifted_index_word) $buffering 1
  current_shifted_index_word_right_shifted := (ZERO_1 && ( $slice current_shifted_index_word 55 1 ) ) $buffering 1
  current_increment := ((ZERO_1 && (last_root_estimate | current_shifted_index_word_right_shifted)) && ZERO_1) $buffering 1
  current_residue := (last_residue - current_increment) $buffering 1
  current_residue_sign := (last_residue < current_increment) $buffering 1
  $report (fpdiv64bitwise make_new_estimate_56_outargs 	 current_shifted_index_word current_shifted_index_word 	 current_root_estimate current_root_estimate 	 current_shifted_index_word_right_shifted current_shifted_index_word_right_shifted 	 current_increment current_increment 	 current_residue current_residue 	 current_residue_sign current_residue_sign )
}

$volatile $module [short_sqrt_56_core]
$in ( last_root_estimate : $uint<56>   last_residue : $uint<58>   last_shifted_index_word : $uint<56>   last_index : $uint<8>  )
$out ( next_root_estimate : $uint<56>   next_residue : $uint<58>   next_last_shifted_index_word : $uint<56>   sticky_flag : $uint<1>  )
$is
{
  current_index := ( $mux (last_index > 0 ) (last_index - 1 )  0  )  $buffering 1
  $report (fpdiv64bitwise short_sqrt_56_core_in_args 	 last_root_estimate last_root_estimate 	 last_residue last_residue 	 last_shifted_index_word last_shifted_index_word 	 last_index last_index 	 current_index current_index )
  $volatile 	$call make_new_estimate_56 (last_root_estimate last_residue last_shifted_index_word ) (current_root_estimate current_residue current_residue_sign ) 
  next_root_estimate := ( $mux ( ~ current_residue_sign ) current_root_estimate  last_root_estimate )  $buffering 1
  next_residue_before_shift := ( $mux ( ~ current_residue_sign ) current_residue  last_residue )  $buffering 1
  next_residue := (( $slice next_residue_before_shift 56 0 )  && ZERO_1) $buffering 1
  sticky_flag := (next_residue != 0 ) $buffering 1
  next_last_shifted_index_word := (ZERO_1 && ( $slice last_shifted_index_word 55 1 ) ) $buffering 1
  $report (fpdiv32bitwise short_sqrt_56_core_out_args 	 next_residue next_residue 	 next_root_estimate next_root_estimate 	 next_last_shifted_index_word next_last_shifted_index_word )
}

$operator $module [short_sqrt_56]
$in ( X : $uint<56>  )
$out ( sticky : $uint<1>   root_X : $uint<56>  )
$is
{
  $report (fpdiv64bitwise X__ 	 X X )
  $volatile start_index := 55  $buffering 1
  $report (fpdiv64bitwise start_index__ 	 start_index start_index )
  $volatile start_root_estimate := _h80000000000000  $buffering 1
  $report (fpdiv64bitwise start_root_estimate__ 	 start_root_estimate start_root_estimate )
  $volatile start_residue := (((( $slice X 55 54 )  - 1 ) && ( $slice X 53 0 ) ) && ZERO_2) $buffering 1
  $report (fpdiv64bitwise start_residue__ 	 start_residue start_residue )
  $volatile start_shifted_index_word := _h80000000000000  $buffering 1
  $report (fpdiv64bitwise start_shifted_index_word__ 	 start_shifted_index_word start_shifted_index_word )
  $branchblock [loop]
  {
    $dopipeline $depth 3 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi last_root_estimate := 			  start_root_estimate $on   $entry 			  next_root_estimate $on   $loopback 
    // type of target is $uint<56>
    $phi last_residue := 			  start_residue $on   $entry 			  next_last_residue $on   $loopback 
    // type of target is $uint<58>
    $phi last_shifted_index_word := 			  start_shifted_index_word $on   $entry 			  next_last_shifted_index_word $on   $loopback 
    // type of target is $uint<56>
    $phi last_index := 			  start_index $on   $entry 			  next_last_index $on   $loopback 
    // type of target is $uint<8>
    $endmerge
    $report (fpdiv64bitwise short_sqrt_64_status 			 last_index last_index 			 last_root_estimate last_root_estimate 			 last_residue last_residue 			 last_shifted_index_word last_shifted_index_word )
    $volatile next_last_index_0 := ( $mux (last_index > 0 ) (last_index - 1 )  0  )  $buffering 1
    $volatile next_last_index_1 := ( $mux (last_index > 1 ) (last_index - 2 )  0  )  $buffering 1
    $volatile next_last_index := ( $mux (last_index > 2 ) (last_index - 3 )  0  )  $buffering 1
    $volatile continue_flag := ((next_last_index > 0 ) & (last_residue != 0 )) $buffering 1
    $volatile 			$call short_sqrt_56_core (last_root_estimate last_residue last_shifted_index_word last_index ) (next_root_estimate_0 next_last_residue_0 next_last_shifted_index_word_0 sticky_flag_0 ) 
    $volatile 			$call short_sqrt_56_core (next_root_estimate_0 next_last_residue_0 next_last_shifted_index_word_0 next_last_index_0 ) (next_root_estimate_1 next_last_residue_1 next_last_shifted_index_word_1 sticky_flag_1 ) 
    $volatile 			$call short_sqrt_56_core (next_root_estimate_1 next_last_residue_1 next_last_shifted_index_word_1 next_last_index_1 ) (next_root_estimate next_last_residue next_last_shifted_index_word sticky_flag ) 
    $while continue_flag
  }
  ( next_root_estimate => root_estimate  sticky_flag => sticky_out )
  sticky := sticky_out $buffering 2// bits of buffering = 2. 
  root_X := root_estimate $buffering 2// bits of buffering = 112. 
  $attribute output_buffering 0
}

$volatile $module [round_e_64]
$in ( sticky_flag : $uint<1>   signed_unbiased_exponent : $int<13>   padded_mantissa : $uint<56>  )
$out ( result : $float<11,52>  )
$is
{
  ue_13 := ($bitcast ($uint<13>) signed_unbiased_exponent ) $buffering 1
  m_62 := (( $slice padded_mantissa 54 0 )  && ZERO_7) $buffering 1
  $report (round_e_64 in_args__ 	 signed_unbiased_exponent signed_unbiased_exponent 	 padded_mantissa padded_mantissa 	 ue_13 ue_13 	 m_62 m_62 )
  $volatile 	$call round_64_extn (sticky_flag ZERO_1 ue_13 m_62 ) (r_ue_13 r_m_52 ) 
  ur64 := ((ZERO_1 && ( $slice r_ue_13 10 0 ) ) && r_m_52) $buffering 1
  result := ($bitcast ($float<11,52>) ur64 ) $buffering 1
  $report (round_e_64 out_args__ 	 ur64 ur64 )
}

$module [fpsqrt64_bit_wise]
$in ( a : $float<11,52>  )
$out ( sqrt_a : $float<11,52>  )
$is
{
  $volatile 	$call classify_and_prepare_64 (a ) (e_e e_m special_case special_case_result ) 
  $report (fpdiv64bitwise fpsqrt64_bit_wise_in_args__ 	 a a 	 e_e e_e 	 e_m e_m 	 special_case special_case 	 special_case_result special_case_result )
  $guard (~special_case) $call short_sqrt_56 (e_m ) (sticky s_e_m ) 
  $guard (~special_case) $report (fpdiv64bitwise fpsqrt64_bit_wise_post_short_sqrt 	 sticky sticky 	 e_m e_m 	 s_e_m s_e_m )
  $volatile s_e_e := ( $mux ((e_e < 0 ) & (e_e == -1 )) 0   (e_e >> 1 ) )  $buffering 1
  $report (fpdiv64bitwise fpsqrt64_bit_wise_to_round 	 s_e_e s_e_e 	 s_e_m s_e_m )
  $volatile sticky_qualified := ( $mux special_case _b0   sticky )  $buffering 1
  $volatile s_e_e_qualified := ( $mux special_case _b0   s_e_e )  $buffering 1
  $volatile s_e_m_qualified := ( $mux special_case _b0   s_e_m )  $buffering 1
  $volatile 	$call round_e_64 (sticky_qualified s_e_e_qualified s_e_m_qualified ) (fsqrt64_normalized_result ) 
  $volatile ur := ($bitcast ($uint<64>) fsqrt64_normalized_result ) $buffering 1
  $report (fpdiv64bitwise fpsqrt64_bit_wise_from_round 	 ur ur )
  $volatile sqrt_a := ( $mux special_case special_case_result  fsqrt64_normalized_result )  $buffering 1
  $attribute delay 3
}

$volatile $module [fpcmp64]
$in ( a : $float<11,52>   b : $float<11,52>   e_flag : $uint<1>  )
$out ( cmp_flags : $uint<2>  )
$is
{
  $volatile 	$call classify_64 (a ) (a_zero a_normal a_denormal a_inf a_nan ) 
  $volatile 	$call classify_64 (b ) (b_zero b_normal b_denormal b_inf b_nan ) 
  ua := ($bitcast ($uint<64>) a ) $buffering 1
  ub := ($bitcast ($uint<64>) b ) $buffering 1
  a_sign := (ua [] 63 ) $buffering 1
  a_rest := ( $slice ua 62 0 )  $buffering 1
  b_sign := (ub [] 63 ) $buffering 1
  b_rest := ( $slice ub 62 0 )  $buffering 1
  $volatile 	$call compare64 ((($bitcast ($uint<1>) _b0 ) && a_rest) (($bitcast ($uint<1>) _b0 ) && b_rest) ) (G E ) 
  a_b := ( ~ (G | E) ) $buffering 1
  b_a := G $buffering 1
  u_a_e_b := ((a_sign == b_sign) & E) $buffering 1
  $volatile 	$call fcmpBase (a_zero a_nan a_sign b_zero b_nan b_sign a_b b_a u_a_e_b ) (cmp_flags ) 
  $report (fpunit_exec fpcmp64_trace__ 	 a a 	 b b 	 cmp_flags cmp_flags )
}

$pipeline $depth 7 $fullrate $module [fp16_add_for_ecg]
$in ( f1 : $uint<16>   f2 : $uint<16>  )
$out ( result : $uint<16>  )
$is
{
  $call faddsub16 (f1 f2 ZERO_1 ) (result ) 
}

$pipeline $depth 7 $fullrate $module [fdtoi_for_ecg]
$in ( X : $float<11,52>  )
$out ( Y : $int<32>  )
$is
{
  $call fdtoi_op (X ) (Y ) 
}

$pipeline $depth 7 $fullrate $module [fdtos_for_ecg]
$in ( X : $float<11,52>  )
$out ( RESULT : $float<8,23>  )
$is
{
  $call DoubleToSingle (X ) (needs_denorm extn_result ) 
  $volatile 	$call round_fp_32 (extn_result ) (s_result_fast ) 
  $guard (needs_denorm) $call denormalize_fp_32 (extn_result ) (s_result_slow ) 
  RESULT := ($bitcast ($float<8,23>) ( $mux needs_denorm s_result_slow  s_result_fast )  ) $buffering 1// bits of buffering = 32. 
}

$pipeline $depth 7 $fullrate $module [fitod64_for_ecg]
$in ( X : $uint<32>  )
$out ( Y : $float<11,52>  )
$is
{
  $volatile 	$call fitod64 (X ) (uY ) 
  Y := uY $buffering 1// bits of buffering = 64. 
}

$pipeline $depth 7 $fullrate $module [fitos32_for_ecg]
$in ( X : $uint<32>  )
$out ( Y : $float<8,23>  )
$is
{
  $volatile 	$call fitod64 (X ) (dY ) 
  $call DoubleToSingle (dY ) (denorm_dY extn_dY ) 
  $volatile 	$call round_fp_32 (extn_dY ) (rY ) 
  $guard (denorm_dY) $call denormalize_fp_32 (extn_dY ) (nrY ) 
  Y := ($bitcast ($float<8,23>) ( $mux denorm_dY nrY  rY )  ) $buffering 1// bits of buffering = 32. 
}

$pipeline $depth 7 $fullrate $module [fp16_mul_for_ecg]
$in ( f1 : $uint<16>   f2 : $uint<16>  )
$out ( result : $uint<16>  )
$is
{
  $call fmul16 (f1 f2 ) (result ) 
}

$volatile $module [fnegs_64]
$in ( f : $float<11,52>  )
$out ( nf : $float<11,52>  )
$is
{
  uf := ($bitcast ($uint<64>) f ) $buffering 1
  nuf := (( ~ (uf [] 63 ) ) && ( $slice uf 62 0 ) ) $buffering 1
  nf := ($bitcast ($float<11,52>) nuf ) $buffering 1
}

$pipeline $depth 7 $fullrate $module [fp32_add_for_ecg]
$in ( X : $float<8,23>   Y : $float<8,23>  )
$out ( RESULT : $float<8,23>  )
$is
{
  $volatile 	$call classFp32 (X ) (xpn xnn xpd xnd xqnan xsnan xpi xni xpz xnz ) 
  x_class := ((((xpn && xnn) && xpd) && (xnd && xqnan)) && (((xsnan && xpi) && xni) && (xpz && xnz))) $buffering 1// bits of buffering = 10. 
  $volatile 	$call classFp32 (Y ) (ypn ynn ypd ynd yqnan ysnan ypi yni ypz ynz ) 
  y_class := ((((ypn && ynn) && ypd) && (ynd && yqnan)) && (((ysnan && ypi) && yni) && (ypz && ynz))) $buffering 1// bits of buffering = 10. 
  $call fpadd32_op (($bitcast ($uint<32>) X ) x_class ($bitcast ($uint<32>) Y ) y_class ) (denormalize_flag_add extn_result_add ) 
  $volatile 	$call round_fp_32 (extn_result_add ) (adds_result_fast ) 
  $guard (denormalize_flag_add) $call denormalize_fp_32 (extn_result_add ) (adds_result_slow ) 
  $volatile RESULT := ($bitcast ($float<8,23>) ( $mux denormalize_flag_add adds_result_slow  adds_result_fast )  ) $buffering 1
  $attribute input_buffering 2
}

$pipeline $depth 7 $fullrate $module [fp64_add_for_ecg]
$in ( X : $float<11,52>   Y : $float<11,52>  )
$out ( RESULT : $float<11,52>  )
$is
{
  $volatile 	$call classFp64 (X ) (xpn xnn xpd xnd xqnan xsnan xpi xni xpz xnz ) 
  x_class := ((((xpn && xnn) && xpd) && (xnd && xqnan)) && (((xsnan && xpi) && xni) && (xpz && xnz))) $buffering 1// bits of buffering = 10. 
  $volatile 	$call classFp64 (Y ) (ypn ynn ypd ynd yqnan ysnan ypi yni ypz ynz ) 
  y_class := ((((ypn && ynn) && ypd) && (ynd && yqnan)) && (((ysnan && ypi) && yni) && (ypz && ynz))) $buffering 1// bits of buffering = 10. 
  $call fpadd64_op (ZERO_1 ONE_1 _b0  _b0  _b0  _b0  ($bitcast ($uint<64>) X ) x_class ($bitcast ($uint<64>) Y ) y_class ) (denormalize_flag_add extn_result_add ) 
  $volatile 	$call round_fp_64 (extn_result_add ) (addd_result_fast ) 
  $guard (denormalize_flag_add) $call denormalize_fp_64 (extn_result_add ) (addd_result_slow ) 
  $volatile RESULT := ($bitcast ($float<11,52>) ( $mux denormalize_flag_add addd_result_slow  addd_result_fast )  ) $buffering 1
  $attribute input_buffering 2
}

$pipeline $depth 7 $fullrate $module [fp32_mul_for_ecg]
$in ( X : $float<8,23>   Y : $float<8,23>  )
$out ( RESULT : $float<8,23>  )
$is
{
  $volatile 	$call classFp32 (X ) (xpn xnn xpd xnd xqnan xsnan xpi xni xpz xnz ) 
  x_class := ((((xpn && xnn) && xpd) && (xnd && xqnan)) && (((xsnan && xpi) && xni) && (xpz && xnz))) $buffering 1// bits of buffering = 10. 
  $volatile 	$call classFp32 (Y ) (ypn ynn ypd ynd yqnan ysnan ypi yni ypz ynz ) 
  y_class := ((((ypn && ynn) && ypd) && (ynd && yqnan)) && (((ysnan && ypi) && yni) && (ypz && ynz))) $buffering 1// bits of buffering = 10. 
  $call fpmul32_op (($bitcast ($uint<32>) X ) x_class ($bitcast ($uint<32>) Y ) y_class ) (denormalize_flag_mul extn_result_mul ) 
  $volatile 	$call round_fp_32 (extn_result_mul ) (muls_result_fast ) 
  $guard (denormalize_flag_mul) $call denormalize_fp_32 (extn_result_mul ) (muls_result_slow ) 
  $volatile RESULT := ($bitcast ($float<8,23>) ( $mux denormalize_flag_mul muls_result_slow  muls_result_fast )  ) $buffering 1
  $attribute input_buffering 2
}

$pipeline $depth 7 $fullrate $module [fp64_mul_for_ecg]
$in ( X : $float<11,52>   Y : $float<11,52>  )
$out ( RESULT : $float<11,52>  )
$is
{
  $volatile 	$call classFp64 (X ) (xpn xnn xpd xnd xqnan xsnan xpi xni xpz xnz ) 
  x_class := ((((xpn && xnn) && xpd) && (xnd && xqnan)) && (((xsnan && xpi) && xni) && (xpz && xnz))) $buffering 1// bits of buffering = 10. 
  $volatile 	$call classFp64 (Y ) (ypn ynn ypd ynd yqnan ysnan ypi yni ypz ynz ) 
  y_class := ((((ypn && ynn) && ypd) && (ynd && yqnan)) && (((ysnan && ypi) && yni) && (ypz && ynz))) $buffering 1// bits of buffering = 10. 
  $call fpmul64_op (ZERO_1 ONE_1 _b0  _b0  _b0  _b0  ($bitcast ($uint<64>) X ) x_class ($bitcast ($uint<64>) Y ) y_class ) (denormalize_flag_mul extn_result_mul ) 
  $volatile 	$call round_fp_64 (extn_result_mul ) (muld_result_fast ) 
  $guard (denormalize_flag_mul) $call denormalize_fp_64 (extn_result_mul ) (muld_result_slow ) 
  $volatile RESULT := ($bitcast ($float<11,52>) ( $mux denormalize_flag_mul muld_result_slow  muld_result_fast )  ) $buffering 1
  $attribute input_buffering 2
}

$pipeline $depth 7 $fullrate $module [fp32_sub_for_ecg]
$in ( X : $float<8,23>   Y : $float<8,23>  )
$out ( RESULT : $float<8,23>  )
$is
{
  $volatile 	$call classFp32 (X ) (xpn xnn xpd xnd xqnan xsnan xpi xni xpz xnz ) 
  x_class := ((((xpn && xnn) && xpd) && (xnd && xqnan)) && (((xsnan && xpi) && xni) && (xpz && xnz))) $buffering 1// bits of buffering = 10. 
  $volatile 	$call classFp32 (Y ) (ypn ynn ypd ynd yqnan ysnan ypi yni ypz ynz ) 
  y_class := ((((ypn && ynn) && ypd) && (ynd && yqnan)) && (((ysnan && ypi) && yni) && (ypz && ynz))) $buffering 1// bits of buffering = 10. 
  $volatile 	$call negate_classification (y_class ) (y_n_class ) 
  uY := ($bitcast ($uint<32>) Y ) $buffering 1// bits of buffering = 32. 
  unY := (( ~ (uY [] 31 ) ) && ( $slice uY 30 0 ) ) $buffering 1// bits of buffering = 32. 
  $call fpadd32_op (($bitcast ($uint<32>) X ) x_class unY y_n_class ) (denormalize_flag_add extn_result_add ) 
  $volatile 	$call round_fp_32 (extn_result_add ) (adds_result_fast ) 
  $guard (denormalize_flag_add) $call denormalize_fp_32 (extn_result_add ) (adds_result_slow ) 
  $volatile RESULT := ($bitcast ($float<8,23>) ( $mux denormalize_flag_add adds_result_slow  adds_result_fast )  ) $buffering 1
  $attribute input_buffering 2
}

$pipeline $depth 7 $fullrate $module [fp64_sub_for_ecg]
$in ( X : $float<11,52>   Y : $float<11,52>  )
$out ( RESULT : $float<11,52>  )
$is
{
  $volatile 	$call classFp64 (X ) (xpn xnn xpd xnd xqnan xsnan xpi xni xpz xnz ) 
  x_class := ((((xpn && xnn) && xpd) && (xnd && xqnan)) && (((xsnan && xpi) && xni) && (xpz && xnz))) $buffering 1// bits of buffering = 10. 
  $volatile 	$call classFp64 (Y ) (ypn ynn ypd ynd yqnan ysnan ypi yni ypz ynz ) 
  y_class := ((((ypn && ynn) && ypd) && (ynd && yqnan)) && (((ysnan && ypi) && yni) && (ypz && ynz))) $buffering 1// bits of buffering = 10. 
  $volatile 	$call negate_classification (y_class ) (y_n_class ) 
  uY := ($bitcast ($uint<64>) Y ) $buffering 1// bits of buffering = 64. 
  unY := (( ~ (uY [] 63 ) ) && ( $slice uY 62 0 ) ) $buffering 1// bits of buffering = 64. 
  $call fpadd64_op (ZERO_1 ONE_1 _b0  _b0  _b0  _b0  ($bitcast ($uint<64>) X ) x_class unY y_n_class ) (denormalize_flag_add extn_result_add ) 
  $volatile 	$call round_fp_64 (extn_result_add ) (addd_result_fast ) 
  $guard (denormalize_flag_add) $call denormalize_fp_64 (extn_result_add ) (addd_result_slow ) 
  $volatile RESULT := ($bitcast ($float<11,52>) ( $mux denormalize_flag_add addd_result_slow  addd_result_fast )  ) $buffering 1
  $attribute input_buffering 2
}

$volatile $module [fpu_increment_64]
$in ( A : $uint<64>  )
$out ( SUM : $uint<64>  )
$is
{
  $volatile A0 := ( $slice A 15 0 )  $buffering 1
  $volatile A1 := ( $slice A 31 16 )  $buffering 1
  $volatile A2 := ( $slice A 47 32 )  $buffering 1
  $volatile A3 := ( $slice A 63 48 )  $buffering 1
  $volatile 	$call adder_18 (A0 0  ONE_1 ) (CIN1_S0 CIN1_C0 ) 
  $volatile 	$call adder_18 (A1 0  ONE_1 ) (CIN1_S1 CIN1_C1 ) 
  $volatile 	$call adder_18 (A2 0  ONE_1 ) (CIN1_S2 CIN1_C2 ) 
  $volatile 	$call adder_18 (A3 0  ONE_1 ) (CIN1_S3 CIN1_C3 ) 
  $volatile P0 := (A0 == ( ~ 0  )) $buffering 1
  $volatile P1 := (A1 == ( ~ 0  )) $buffering 1
  $volatile P2 := (A2 == ( ~ 0  )) $buffering 1
  $volatile P3 := (A3 == ( ~ 0  )) $buffering 1
  $volatile sum_0 := CIN1_S0 $buffering 1
  $volatile carry_0 := P0 $buffering 1
  $volatile sum_1 := ( $mux P0 CIN1_S1  A1 )  $buffering 1
  $volatile carry_1 := (P1 & carry_0) $buffering 1
  $volatile sum_2 := ( $mux carry_1 CIN1_S2  A2 )  $buffering 1
  $volatile carry_2 := ((P0 & P1) & P2) $buffering 1
  $volatile sum_3 := ( $mux carry_2 CIN1_S3  A3 )  $buffering 1
  SUM := ((sum_3 && sum_2) && (sum_1 && sum_0)) $buffering 1
}

$pipeline $depth 7 $fullrate $module [fstod_for_ecg]
$in ( X : $float<8,23>  )
$out ( RESULT : $float<11,52>  )
$is
{
  $volatile 	$call SingleToDouble (X ) (r ) 
  RESULT := r $buffering 1// bits of buffering = 64. 
}

$pipeline $depth 7 $fullrate $module [fstoi_for_ecg]
$in ( X : $float<8,23>  )
$out ( Y : $int<32>  )
$is
{
  $volatile 	$call SingleToDouble (X ) (Xd ) 
  $call fdtoi_op (Xd ) (Y ) 
}

$pipeline $depth 7 $fullrate $module [fp16_sub_for_ecg]
$in ( f1 : $uint<16>   f2 : $uint<16>  )
$out ( result : $uint<16>  )
$is
{
  $call faddsub16 (f1 f2 ONE_1 ) (result ) 
}

$volatile $module [increment_64]
$in ( A : $uint<64>  )
$out ( B : $uint<64>  )
$is
{
  AH := ( $slice A 63 32 )  $buffering 1
  AL := ( $slice A 31 0 )  $buffering 1
  $volatile 	$call increment_32 (AL ) (BL ) 
  $volatile 	$call increment_32 (AH ) (tBH ) 
  B := (( $mux (( ~ AL ) == 0 ) tBH  AH )  && BL) $buffering 1
}

$volatile $module [u64_sll]
$in ( X : $uint<64>   S : $uint<7>  )
$out ( Y : $uint<64>  )
$is
{
  X0 := ( $mux (S [] 0 ) (( $slice X 62 0 )  && ZERO_1)  X )  $buffering 1
  X1 := ( $mux (S [] 1 ) (( $slice X0 61 0 )  && ZERO_2)  X0 )  $buffering 1
  X2 := ( $mux (S [] 2 ) (( $slice X1 59 0 )  && ZERO_4)  X1 )  $buffering 1
  X3 := ( $mux (S [] 3 ) (( $slice X2 55 0 )  && ZERO_8)  X2 )  $buffering 1
  X4 := ( $mux (S [] 4 ) (( $slice X3 47 0 )  && ZERO_16)  X3 )  $buffering 1
  X5 := ( $mux (S [] 5 ) (( $slice X4 31 0 )  && ZERO_32)  X4 )  $buffering 1
  Y := ( $mux (S [] 6 ) _b0   X5 )  $buffering 1
}

$volatile $module [u64_srl]
$in ( X : $uint<64>   S : $uint<7>  )
$out ( Y : $uint<64>  )
$is
{
  X0 := ( $mux (S [] 0 ) (ZERO_1 && ( $slice X 63 1 ) )  X )  $buffering 1
  X1 := ( $mux (S [] 1 ) (ZERO_2 && ( $slice X0 63 2 ) )  X0 )  $buffering 1
  X2 := ( $mux (S [] 2 ) (ZERO_4 && ( $slice X1 63 4 ) )  X1 )  $buffering 1
  X3 := ( $mux (S [] 3 ) (ZERO_8 && ( $slice X2 63 8 ) )  X2 )  $buffering 1
  X4 := ( $mux (S [] 4 ) (ZERO_16 && ( $slice X3 63 16 ) )  X3 )  $buffering 1
  X5 := ( $mux (S [] 5 ) (ZERO_32 && ( $slice X4 63 32 ) )  X4 )  $buffering 1
  Y := ( $mux (S [] 6 ) _b0   X5 )  $buffering 1
}

$pipeline $depth 3 $buffering 1 $fullrate $module [u64_shift]
$in ( is_sll : $uint<1>   is_srl : $uint<1>   x : $uint<64>   shift_amount : $uint<7>  )
$out ( result : $uint<64>  )
$is
{
  $volatile 	$call u64_sll (x shift_amount ) (result_sll ) 
  $volatile 	$call u64_srl (x shift_amount ) (result_srl ) 
  result := ( $mux is_sll result_sll  result_srl )  $buffering 2// bits of buffering = 128. 
}

$volatile $module [u64_shift_sticky]
$in ( is_sll : $uint<1>   is_srl : $uint<1>   x : $uint<64>   shift_amount : $uint<7>  )
$out ( result : $uint<64>   sticky : $uint<1>  )
$is
{
  $volatile 	$call u64_sll (x shift_amount ) (result_sll ) 
  $volatile 	$call u64_sr_special (x shift_amount ) (result_srl shifted_bit_rep ) 
  sticky := ( $mux is_srl shifted_bit_rep  _b0  )  $buffering 1
  result := ( $mux is_sll result_sll  result_srl )  $buffering 1
}

